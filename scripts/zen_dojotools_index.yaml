sequence:
  - alias: Show Help
    choose:
      - conditions:
          - condition: template
            value_template: "{{ mode == 'help' }}"
        sequence:
          - action: script.zen_dojotools_query
            metadata: {}
            data:
              mode: help
              filter_json: "{} "
            response_variable: zen_query_help
          - variables:
              query_help: "{{ zen_query_help | default({}) | tojson }}"
              help_json: |
                {{
                  {
                    "tool": "Zen DojoTools Index",
                    "version": "3.9.5+ RC1",
                    "intent": "High-resolution reasoning. Convert arbitrary entity + label sets into a unified hypergraph suitable for fusion, summarization, planning, and contextual inference.",
                    "you_should_use_this_tool_when": [
                      "You need to combine labels, entities, or both into a logical result set.",
                      "You need a graph view (nodes/edges/adjacency) rather than a flat list.",
                      "You are preparing input for a summarizer, fusion model, or kata update.",
                      "You need deterministic state discovery that respects Home Assistant labels, drawers, areas, and metadata.",
                      "You want to invert, intersect, union, or difference two sets safely.",
                      "You need to pre-filter results via a ZenQuery filter_json block."
                    ],
                    "core_behavior": {
                      "pipeline_order": "Collect and Join >> ZQ1 Filter >> Hypergraph Generation >> Expansion with Inspect.",
                      "join_logic": "Computes op1 (entities_1 or label_1) and op2 (entities_2 or label_2), evaluates them with operator AND/OR/NOT/XOR/*.",
                      "zq1_filtering": "If filter_json is provided, results are passed through ZenQuery before expansion.",
                      "graph_mode": "If mode='hypergraph', the final result emits nodes, edges, and adjacency groups instead of or in addition to simple lists.",
                      "expansion": "If expand_entities=true, details are populated via Zen Inspect."
                    },
                    "modes": {
                      "normal": "Outputs lists suitable for standard Dojo operations.",
                      "hypergraph": "Outputs {nodes, edges, expanded}. Use this for fusion, summarizers, drift detection, intent resolution, and reasoning."
                    },
                    "inputs": {
                      "entities_1": "List of entity_ids.",
                      "label_1": "Single label or text token resolved by label_entities().",
                      "entities_2": "Second entity list.",
                      "label_2": "Second label or token.",
                      "operator": "AND | OR | NOT | XOR | * (full label graph).",
                      "expand_entities": "true/false — expands metadata, drawers, attributes.",
                      "filter_json": "Optional dict following ZenQuery schema.",
                      "mode": "normal | hypergraph",
                      "timeout": "Indexer callback timeout in seconds."
                    },
                    "filter_json": {
                      "overview": "ZenQuery-style dict applied after primary set resolution. Ideal for trimming results before fusion.",
                      "query_help": query_help,
                      "simple_examples": {
                        "domain": {"domain": "light"},
                        "state": {"state": "on"},
                        "label": {"label": "kitchen"}
                      },
                      "compound_examples": {
                        "domain_and_label": {"domain": "sensor", "label": "environment"},
                        "state_exclusion": {"state_not": ["unknown", "unavailable"]},
                        "threshold": {"state_op": ">", "state_value": 50}
                      },
                      "advanced_examples": {
                        "graph_edge_focus": {"edge_label": "hvac"},
                        "multi_filter": {"domain": "switch", "label": "office", "state": "on"}
                      }
                    },
                    "hypergraph_output": {
                      "nodes": "The entity_ids that survived set logic and filtering.",
                      "edges": "All labels associated across all surviving entities.",
                      "adjacency": "Cross-product of entities and labels.",
                      "expanded": "Optional deep detail block (attributes, drawers, related labels)."
                    },
                    "full_output_structure": {
                      "result.simple": "Flat entity list.",
                      "result.expanded": "If requested, detailed entity metadata.",
                      "result.adjacent_labels": "Labels connected to the result set.",
                      "result.index": "Structured mapping of entity → labels.",
                      "result.drawers": "Drawer matches tied to entities.",
                      "result.drawer_adjacent_labels": "Labels found inside drawers.",
                      "result.hypergraph": "Graph object when mode='hypergraph'.",
                      "inputs": "Echo of inputs for audit & reasoning.",
                      "operator": "Operator used.",
                      "error": "Timeout or other error info."
                    },
                    "usage_examples": {
                      "Example 1 — All lights in the office": {
                        "label_1": "office",
                        "filter_json": {"domain": "light"}
                      },
                      "Example 2 — HVAC related sensors, hypergraph mode": {
                        "label_1": "hvac",
                        "mode": "hypergraph",
                        "expand_entities": true
                      },
                      "Example 3 — Lights AND Switches in two rooms": {
                        "label_1": "kitchen",
                        "label_2": "living_room",
                        "operator": "OR",
                        "filter_json": {"domain": ["light","switch"]}
                      },
                      "Example 4 — All entities with environmental data > 60": {
                        "label_1": "environment",
                        "filter_json": {"state_op": ">", "state_value": 60}
                      },
                      "Example 5 — Build a root graph for Summarizer or Fusion": {
                        "label_1": "climate",
                        "expand_entities": true,
                        "mode": "hypergraph"
                      }
                    },
                    "best_practices": [
                      "Use (Hyper)Index before any fusion or summarization to avoid bloated context.",
                      "Prefer labels as the primary driver, entities only when needed.",
                      "Use expand_entities sparingly — hypergraph mode is already powerful.",
                      "Use filter_json to reduce post-processing load.",
                      "Use operator '*' with no labels to get a system-wide label graph."
                    ],
                    "warnings": [
                      "Expanded entity blocks can get large; avoid unless required.",
                      "Hypergraph mode produces more data — summarizers should prune aggressively.",
                      "If filter_json is malformed, it defaults to an empty filter."
                    ],
                    "ai_user_guidance": [
                      "Use 'mode': 'help' at any time to retrieve the full JSON schema.",
                      "Use (Hyper)Index as your first step when reasoning about groups of devices.",
                      "Use hypergraph mode to understand relationships, not just lists.",
                      "Use filter_json to stay efficient and avoid overwhelming context.",
                      "Before writing a kata or fusion output, get a fresh HyperIndex snapshot.",
                      "If a result is empty unexpectedly, re-run in normal mode to debug."
                    ]
                  }
                }}
          - stop: Return help JSON
            response_variable: help_json
  - variables:
      operator: "{{ operator | default('AND') }}"
      _raw_filter: "{{ filter_json | default('{}') }}"
      parsed_filter: |-
        {%- set txt = (_raw_filter | string | trim) -%}
        {%- if _raw_filter is mapping -%}
          {{ _raw_filter }}
        {%- elif txt == '' -%}
          {}
        {%- else -%}
          {%- set parsed = txt | from_json -%}
          {{ parsed if parsed is mapping else {} }}
        {%- endif -%}
      has_filter: |-
        {% if parsed_filter is mapping and parsed_filter | length > 0 %}
          true
        {% else %}
          false
        {% endif %}
  - variables:
      mode: "{{ mode | default('normal') }}"
      is_index_command: "{{ index_command is defined and index_command | length > 0 }}"
      correlation_id: |-
        {% if is_index_command %}
          {{ now().isoformat() ~ '-' ~ (range(1000) | random) }}
        {% else %} '' {% endif %}
      timeout_seconds: "{{ timeout | default(2) }}"
  - choose:
      - conditions:
          - condition: template
            value_template: "{{ is_index_command }}"
        sequence:
          - event: zen_indexer_request
            event_data:
              index_command: "{{ index_command }}"
              correlation_id: "{{ correlation_id }}"
          - wait_for_trigger:
              - trigger: event
                event_type: zen_index_response
                event_data:
                  correlation_id: "{{ correlation_id }}"
            timeout:
              seconds: "{{ timeout_seconds }}"
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ wait.trigger is defined and wait.trigger is not none }}"
                sequence:
                  - variables:
                      simple: >-
                        {{ wait.trigger.event.data.response.result.simple |
                        default([]) }}
                      index_timeout: false
              - conditions: []
                sequence:
                  - variables:
                      simple: []
                      index_timeout: true
                      timeout_error_msg: Indexer call timeout {{ timeout_seconds }}s
  - variables:
      index_command: ""
      op1: >-
        {% set ents = simple if (simple is defined and simple) else [] %} {% if
        ents | length == 0 %}
          {% set ents = entities_1 | default([]) %}
          {% if ents | length == 0 and label_1 %}
            {{ label_entities(label_1) }}
          {% else %}
            {{ ents }}
          {% endif %}
        {% else %}
          {{ ents }}
        {% endif %}
      op2: >-
        {% set ents = entities_2 | default([]) %} {% set has_label_2 = (label_2
        is defined and label_2 | default('') | trim != '') %} {% if ents |
        length == 0 and has_label_2 %}
          {{ label_entities(label_2) }}
        {% else %}
          {{ ents }}
        {% endif %}
      op1_empty: "{{ op1 | length == 0 }}"
      op2_empty: "{{ op2 | length == 0 }}"
      setop: "{{ operator | default('AND') | upper }}"
  - variables:
      entities_base: |-
        {% if not op1_empty and op2_empty %}
          {{ op1 }}
        {% elif not op2_empty and op1_empty %}
          {{ op2 }}
        {% elif not op1_empty and not op2_empty %}
          {% if setop == 'AND' %}
            {{ op1 | intersect(op2) }}
          {% elif setop == 'OR' %}
            {{ (op1 + op2) | unique | list }}
          {% elif setop == 'NOT' %}
            {{ op1 | difference(op2) }}
          {% elif setop == 'XOR' %}
            {{ op1 | symmetric_difference(op2) }}
          {% else %}
            {{ (op1 + op2) | unique | list }}
          {% endif %}
        {% else %}
          []
        {% endif %}
  - alias: "Zen Query: Filter entities_base if filter passed"
    if:
      - condition: template
        value_template: "{{ has_filter }}"
        alias: "Has Filter: filter_json exists and is mapping"
    then:
      - action: script.zen_dojotools_query
        metadata: {}
        data:
          mode: query
          filter_json: "{{ filter_json | default('{}') }}"
          target_entities: "{{ entities_base }}"
        response_variable: response_zen_query
      - variables:
          response_entities: "{{ response_zen_query.baselist | default([]) }}"
          fallback_entities_base: "{{ entities_base | default([]) }}"
          strict_mode: "{{ strict | default(false) }}"
          entities_base: |-
            {% if strict_mode %}
              {{ response_entities }}
            {% else %}
              {{ response_entities if response_entities else fallback_entities_base }}
            {% endif %}
  - choose:
      - conditions:
          - condition: template
            value_template: "{{ expand_entities }}"
            alias: Expand = true
        sequence:
          - action: script.zen_dojotools_inspect
            data:
              entity_id: "{{ entities_base | list }}"
            response_variable: response
          - variables:
              expanded_entities: "{{ response.results | default([]) }}"
              matched_drawers: "{{ response.drawers | default('[]') }}"
              matched_drawer_labels: "{{ response.adjacent_labels | default('[]') }}"
      - conditions: []
        sequence:
          - variables:
              expanded_entities: "{{ entities_base }}"
              matched_drawers: []
              matched_drawer_labels: []
        alias: Expand = false
    alias: "Prepare [ Expand ] Result Set "
  - variables:
      adjacent_labels: |-
        {%- set ns = namespace(labels=[]) -%} {%- for e in entities_base -%}
          {%- set ns.labels = ns.labels + (labels(e) | list) -%}
        {%- endfor -%} {{ ns.labels | unique | list | sort }}
      result_index: |-
        {% if op1_empty and op2_empty %}
          {{ labels() | list | sort }}
        {% else %}
          {% set ns = namespace(idx=[]) %}
          {% for e in entities_base %}
            {% set ns.idx = ns.idx + [[ e, (labels(e) | list) ]] %}
          {% endfor %}
          {{ ns.idx }}
        {% endif %}
  - variables:
      hypergraph: |-
        {% if mode == 'hypergraph' %}
          {
            "nodes": {{ entities_base | tojson }},
            "edges": {{ adjacent_labels | tojson }},
            "expanded": {{ expanded_entities | tojson }}
          }
        {% else %}
          {}
        {% endif %}
  - variables:
      label_entity_logic_result_raw: |-
        {{
          {
            "result": {
              "simple": entities_base | default([]) | list,
              "expanded": expanded_entities | default({}),
              "adjacent_labels": adjacent_labels | default([]) | list,
              "index": result_index | default([]),
              "drawers": matched_drawers | default([]) | list,
              "drawer_adjacent_labels": matched_drawer_labels | default([]) | list,
              "hypergraph": hypergraph | default({})
            },
            "inputs": {
              "mode": mode | default('normal'),
              "entities_1": entities_1 | default([]) | list,
              "label_1": label_1 | default(''),
              "entities_2": entities_2 | default([]) | list,
              "label_2": label_2 | default(''),
              "strict": strict | default(false),
              "expand_entities": expand_entities | default(false)
              
            },
            "operator": "*" if (op1_empty and op2_empty) else setop,
            "error": timeout_error_msg | default(None)
          }
          | tojson
        }}
      label_entity_logic_result: "{{ label_entity_logic_result_raw | from_json | default({}) }}"
  - stop: Zen DojoTools Index Complete
    response_variable: label_entity_logic_result
alias: Zen DojoTools Index (RC1)
description: >
  Zen DojoTools (Hyper)Index (3.9.10 RC1). Universal HyperGraph Index for entity
  and label reasoning.

  Merges labels, entities, drawers, and metadata into a unified, deterministic
  result set. It accepts two input sets (entities or labels), applies logical
  operators (AND/OR/NOT/XOR/*), and resolves the final list using the Zen label
  graph. Optional filtering via filter_json prunes results before expansion.

  When expand_entities=true, the tool uses Zen Inspect to fetch attributes,
  drawers, and related labels. Hypergraph mode outputs a structured graph
  (nodes, edges, adjacency, expanded) ideal for fusion, summarizers, drift
  checks, and reasoning tasks.

  All outputs return as a stable JSON dictionary containing simple lists,
  expanded details, label adjacency, index mappings, drawer results, and any
  errors. Designed for fast, predictable chaining across Friday’s perception and
  reasoning pipelines.

  Strongly recommended: run this tool with mode: help to view the full,
  structured specification and complete filter_json (ZQ-1) schema.
fields:
  mode:
    selector:
      select:
        options:
          - normal
          - hypergraph
          - help
    default: normal
    description: >-
      Index mode. Required, normal (default) - lightweight traditional index,
      hypergraph adds nodes, edges and adjacency, help - usage details incl zq1
      syntax.
  index_command:
    name: Zen Index Command
    description: >-
      Structured query string for parser. Overrides all other fields. Prefer
      discrete fields to the index command. Currently does not pass through
      filter input - use filter_json.
    required: false
    selector:
      text: {}
  entities_1:
    name: Entities 1
    description: one of Entities 1 or Label 1 must be passed.
    required: false
    selector:
      entity:
        multiple: true
  label_1:
    description: one of Label 1 or Entities 1 must be passed.
    name: Label 1
    required: false
    selector:
      text: {}
  entities_2:
    name: Entities 2
    required: false
    selector:
      entity:
        multiple: true
  label_2:
    name: Label 2
    required: false
    selector:
      text: {}
  operator:
    name: Set Operator
    description: Boolean set operator - Default AND if not provided.
    required: false
    default: AND
    selector:
      select:
        options:
          - AND
          - OR
          - NOT
          - XOR
  timeout:
    name: Timeout
    required: false
    default: 2
    selector:
      number:
        min: 0
        max: 5
        step: 0.25
  filter_json:
    selector:
      text:
        multiline: true
    default: "{} "
    description: >-
      Optional filter_json json dict containing a valid ZenQuery filter
      dictionary - MUST see zen_query help for ZQ1 schema and use. Default {}
  strict:
    selector:
      boolean: {}
    description: >
      If true, ZQ1’s output is taken as authoritative even when empty. No
      fallback to the original entity set. Use this for reasoning tasks where an
      empty set is semantically meaningful.
    required: false
    default: false
  expand_entities:
    name: Expand Results
    required: false
    default: false
    selector:
      boolean: {}
mode: parallel
max: 10
icon: mdi:graphql
