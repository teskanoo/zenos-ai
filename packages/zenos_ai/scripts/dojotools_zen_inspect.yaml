script:
  dojotools_zen_inspect:
    sequence:
      - variables:
          entity_list: "{{ entity_id }}"
          results: []
      - repeat:
          for_each: "{{ entity_list }}"
          sequence:
            - variables:
                current_entity: "{{ repeat.item }}"
                labels_raw: "{{ labels(current_entity) }}"
                adjacent_labels: "{{ labels_raw | unique | sort | list | tojson }}"
                raw_volume: "{{ state_attr(current_entity, 'variables') }}"
                is_person: "{{ current_entity.startswith('person.') }}"
                user_id: "{{ state_attr(current_entity, 'user_id') if is_person else none }}"
                last_updated: >-
                  {{ as_timestamp(states[current_entity].last_updated, default=0) |
                  timestamp_local }}
                device_trackers: >-
                  {{ (state_attr(current_entity, 'device_trackers') if is_person
                  else [] ) | tojson }}
                parsed_volume: |
                  {% if raw_volume is string and raw_volume.startswith('{') %}
                    {{ raw_volume | from_json }}
                  {% elif raw_volume is mapping %}
                    {{ raw_volume }}
                  {% else %}
                    {} 
                  {% endif %}
                cab_valid: |
                  {{ raw_volume is mapping and
                     raw_volume.AI_Cabinet_VolumeInfo is defined and
                     raw_volume.AI_Cabinet_VolumeInfo.value is mapping and
                     raw_volume.AI_Cabinet_VolumeInfo.value.validation == "ALLYOURBASEAREBELONGTOUS" }}
                cab_response: |
                  {% if cab_valid %}
                    {{
                      {
                        "id": raw_volume.AI_Cabinet_VolumeInfo.value.id | default(""),
                        "friendly_name": raw_volume.AI_Cabinet_VolumeInfo.value.friendly_name | default(""),
                        "description": raw_volume.AI_Cabinet_VolumeInfo.value.description | default(""),
                        "timestamp": raw_volume.AI_Cabinet_VolumeInfo.timestamp | default(""),
                        "flags": raw_volume.AI_Cabinet_VolumeInfo.flags | default({}),
                        "acls": {
                          "owner": (
                            raw_volume.AI_Cabinet_VolumeInfo.acls.owner[0].entity_id
                            if raw_volume.AI_Cabinet_VolumeInfo.acls is defined and
                               raw_volume.AI_Cabinet_VolumeInfo.acls.owner is defined and
                               raw_volume.AI_Cabinet_VolumeInfo.acls.owner[0].entity_id is defined
                            else ""
                          )
                        },
                        "index": (
                          raw_volume._label_index.value
                          if raw_volume._label_index is defined and raw_volume._label_index.value is defined
                          else []
                        )
                      }
                    }}
                  {% else %}
                    { "defined": false, "error": "Invalid or missing AI Cabinet volume." }
                  {% endif %}
                attr_dict: >-
                  {%- set attrs = states[current_entity].attributes if
                  states[current_entity] else {} %} {%- set ns =
                  namespace(cleaned={}) %} {%- for k, v in attrs.items() %}
                    {%- if v is none %}
                      {%- set ns.cleaned = ns.cleaned | combine({k: none}) %}
                    {%- elif v is string %}
                      {%- set ns.cleaned = ns.cleaned | combine({k: v}) %}
                    {%- elif v is number or v is boolean %}
                      {%- set ns.cleaned = ns.cleaned | combine({k: v}) %}
                    {%- elif v is iterable and not v is string %}
                      {%- set ns.cleaned = ns.cleaned | combine({k: v | list}) %}
                    {%- elif v is mapping %}
                      {%- set inner = namespace(obj={}) %}
                      {%- for ik, iv in v.items() %}
                        {%- if iv is string or iv is number or iv is boolean %}
                          {%- set inner.obj = inner.obj | combine({ik: iv}) %}
                        {%- elif iv is iterable and not iv is string %}
                          {%- set inner.obj = inner.obj | combine({ik: iv | list}) %}
                        {%- else %}
                          {%- set inner.obj = inner.obj | combine({ik: iv | string}) %}
                        {%- endif %}
                      {%- endfor %}
                      {%- set ns.cleaned = ns.cleaned | combine({k: inner.obj}) %}
                    {%- else %}
                      {%- set ns.cleaned = ns.cleaned | combine({k: v | string}) %}
                    {%- endif %}
                  {%- endfor %} {{ ns.cleaned }}
                fallback_response: |-
                  {{
                    {
                      "entity": current_entity | default(''),
                      "state": states(current_entity) | default(''),
                      "last_updated": last_updated,
                      "labels": labels_raw | default([]),
                      "attributes": attr_dict | default({}),
                      "user_id": user_id | default(''),
                      "device_trackers": device_trackers | default([])
                    } | tojson
                  }}
            - variables:
                inference: {}
                results: "{{ results + [fallback_response] }}"
      - variables:
          final_response: |-
            {{
              {
                "results": results
              } | tojson
            }}
      - stop: Multi-entity investigate complete
        response_variable: final_response
    alias: DojoTOOLS Zen Inspect
    mode: parallel
    description: >-
      Inspect (1.3.0) Deep dive on one or more entities.  THis tool lprovides the
      expand function of the Zen Indexer. Accepts a list of entity_ids - dumps
      attributes Exposes volume headers for volumes in the library, Highlights
      device trackers for person domain entities and more! Optional inference
      support is coming soon for an deeper analysis on provided data. Note this file will be renamed next release
    fields:
      entity_id:
        required: true
        selector:
          entity:
            multiple: true
      infer:
        required: false
        selector:
          boolean:
        description: Use local inference to add context to the result (VERY EXPENSIVE call)
      timeout:
        selector:
          number:
            min: 30
            max: 300
            step: 0.25
        name: Timeout
        description: >-
          Timeout, in seconds to wait for the inference return in seconds (Default -
          60, Min - 30, Max - 300, Step - 5)
        default: 60
        required: false
