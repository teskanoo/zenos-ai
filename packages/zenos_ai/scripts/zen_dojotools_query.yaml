script:
  zen_dojotools_query:
    alias: Zen DojoTools Query
    description: >
      Zen DojoTools Query “ZQ-1” (3.9.1 RC1)
      requires zen_query.jinja 1.3.4 or better.
    
      Query is a deterministic entity selector. It takes a starting list of
      entity_ids (or an empty/null list) and runs them through a series of
      filters—domain, labels, areas, device_id, device_class, states, numeric
      ranges, regex, and semantic shortcuts. Each filter narrows the set; results
      are always a clean JSON array of entity_ids.
    
      Core behavior: - If you supply target_entities, Query filters ONLY that list.
      - If target_entities is empty/null AND the filter includes a domain,
        Query auto-builds the starter set from states[domain].
      - If target_entities is empty/null AND no domain is provided, the
        result will be an empty set.
    
      Therefore you must provide a target_entities list or include a domain in the
      filter and leave target_entities empty.
    icon: mdi:filter-cog
    mode: single
    fields:
      mode:
        name: Mode
        description: help = JSON spec, query = run filter
        selector:
          select:
            options:
              - help
              - query
        default: help
      log_result:
        name: Log Result
        description: Write filter + baselist + result to logbook
        selector:
          boolean:
        default: false
      emit_event:
        name: Emit Zen Event
        description: Emit structured zen_event via DojoTools Event Emitter
        selector:
          boolean:
        default: false
      target_entities:
        name: Target Entities
        selector:
          entity:
            multiple: true
        description: >-
          Optional starter list of entities to be filtered. If omitted starts from
          all ents of domain in filter.
      filter_json:
        selector:
          text:
            multiline: true
        default: "{} "
        description: >-
          Optional filter_json json dict containing a valid ZenQuery filter
          dictionary - MUST see help for schema and use. Default {}
    sequence:
      - alias: Show Help
        choose:
          - conditions:
              - condition: template
                value_template: "{{ mode == 'help' }}"
            sequence:
              - variables:
                  help_json: |
                    {{
                      {
                        "tool": "Zen DojoTools Query (ZQ-1)",
                        "version": "1.5.x RC1",
                        "overview":
                          "ZQ-1 is a deterministic, multi-stage entity filtering engine designed for Home Assistant. It consumes flexible JSON filter definitions and produces a fully evaluated list of entity_ids. Every filter acts conjunctively (logical AND), meaning each stage narrows the working set. All logic is safe, non-throwing, and predictable.",
    
                        "philosophy":
                          "The goal of ZQ-1 is to give Friday and the Monastery a *primitive* that behaves like a database WHERE clause: consistent, strict, explicit, and composable. ZQ-1 never guesses. It never expands implicitly except for the domain auto-build rule. Every transformation of the entity set is transparent, repeatable, and explainable.",
    
                        "input_behavior": {
                          "accepted_inputs":
                            "• null\n• a single entity_id string\n• a list of entity_ids\n• any iterables (converted to list)\n• a JSON object describing filter parameters",
                          "normalization_rules":
                            "• null → []\n• string → [string]\n• iterable → list(iterable)\n• non-iterable scalar → []",
                          "initialization_pipeline":
                            "1. Normalize entity_list\n2. If empty AND domain is provided → auto-expand from states[domain]\n3. Begin sequential filtering through each configured step"
                        },
    
                        "fields": {
                          "domain":
                            "Restrict or auto-build the set. If entity_list is empty, ZQ-1 takes all entities from states[domain]. If entity_list is non-empty, ZQ-1 filters them to retain only those whose entity_id starts with domain+'.'",
    
                          "label":
                            "Intersect the working set with label_entities(label). Input is slugified for safety. Label filtering is PURE intersection.",
    
                          "area":
                            "Intersect the working set with all entity_ids located in the given area. ZQ-1 slugifies name, resolves area_id(), then calls area_entities().",
    
                          "device_id":
                            "Intersect the working set with all entities attached to the specified device. Slugify → resolve device_id() → device_entities().",
    
                          "device_class":
                            "Keep entities whose 'device_class' attribute matches the provided string.",
    
                          "state_equals":
                            "Keep only entities whose state value exactly matches this string.",
    
                          "include_states":
                            "Allow only entities whose state is in this list.",
    
                          "exclude_states":
                            "Reject entities whose state is in this list.",
    
                          "numeric_above":
                            "Keep only entities whose state cleanly converts to float() AND whose value is strictly > this threshold.",
    
                          "numeric_below":
                            "Keep only entities whose numeric state is strictly < this threshold.",
    
                          "regex":
                            "Apply Home Assistant’s `is regex()` test to the STATE STRING. Matching entities survive. Non-string or non-matching entities are dropped.",
    
                          "shortcuts": {
                            "numeric":
                              "Quick include-only-numeric. Equivalent to: float(state) is valid.",
                            "stats":
                              "Keep only entities that publish 'state_class'. Useful for energy, utility, trend, Riemann sensors.",
                            "temp":
                              "Keep device_class=='temperature'.",
                            "humidity":
                              "Keep device_class=='humidity'.",
                            "power":
                              "Keep device_class=='power'.",
                            "energy":
                              "Keep device_class=='energy'.",
                            "water":
                              "Keep device_class=='moisture'.",
                            "binary":
                              "Retain only entity_ids beginning with 'binary_sensor.'.",
                            "stats_eligible":
                              "Keep only entities that are:\n"
                              "  • numeric\n"
                              "  • have state_class\n"
                              "  • have unit_of_measurement\n"
                              "  • are NOT disabled (disabled_by == none)\n"
                              "This approximates HA’s long-term statistics eligibility."
                          },
    
                          "sort": {
                            "by": 
                              "Sort key — 'entity_id', 'state', or 'name'.\n"
                              "'name' refers to friendly_name.",
                            "order":
                              "'asc' or 'desc'. Defaults to ascending."
                          }
                        },
    
                        "filter_execution_model":
                          "Each block is executed in order. Each block rewrites pipe.ids. No block expands or adds new items except domain auto-build. Shortcuts are applied AFTER all explicit filters, meaning shortcuts enforce late-stage narrowing logic. If multiple shortcuts are enabled, all must match (logical AND).",
    
                        "error_handling":
                          "• Invalid float() conversion → skip\n• Missing attributes → skip\n• regex against non-string → skip\n• Unknown area/device/label → silently drop all matches (intersection with empty)\n• Everything is safe and deterministic\nZQ-1 never throws template exceptions.",
    
                        "return_value":
                          "Always returns a JSON array (string) of final entity_ids.",
    
                        "examples": {
                          "find_all_lights_on":
                            "{'domain':'light', 'state_equals':'on'}",
    
                          "living_room_motion_binary_sensors":
                            "{'area':'living room', 'shortcuts':{'binary': true}}",
    
                          "high_temperature":
                            "{'shortcuts':{'temp': true}, 'numeric_above': 78}",
    
                          "washing_machine_power_spike":
                            "{'label':'laundry', 'shortcuts':{'power': true}, 'numeric_above': 500}",
    
                          "all_stats_eligible_in_kitchen":
                            "{'area':'kitchen', 'shortcuts':{'stats_eligible': true}}",
    
                          "regex_match_for_heating_modes":
                            "{'domain':'climate', 'regex':'heat|on|aux'}"
                        },
    
                        "usage_instructions":
                          "1. Create a JSON object describing desired filters.\n"
                          "2. Call ZQ-1 with:\n"
                          "     zen_filter(<filter_json>, <entity_list>)\n"
                          "3. Provide null for <entity_list> to auto-build from domain or start empty.\n"
                          "4. Use shortcuts to reduce complexity — they are optimized primitives.\n"
                          "5. After receiving output, treat it as an authoritative filtered list.\n"
                          "6. ZQ-1 is stable and idempotent — running it twice with the same input produces the same output.\n"
                          "7. ZQ-1 does not read historical state. All decisions are based on CURRENT states and attributes."
                      }
                      | tojson
                    }}
                enabled: false
              - variables:
                  help_json: |-
                    {% import 'zenos_ai/zen_query.jinja' as zen %}
                    {{ zen.zen_query_help() | from_json }}
                alias: Load zen_query_help from zen
              - stop: Return help JSON
                response_variable: help_json
      - variables:
          _raw_filter: "{{ filter_json | default('{}') }}"
          parsed_filter: |-
            {% if _raw_filter is mapping %}
              {{ _raw_filter }}
            {% else %}
              {% set text = _raw_filter | trim %}
              {% if text | length == 0 %}
                {}
              {% else %}
                {{ text | from_json(default={}) }}
              {% endif %}
            {% endif %}
          filter_domain: "{{ parsed_filter.get('domain') }}"
      - variables:
          auto_base_list: |-
            {% if (target_entities | count == 0) and filter_domain %}
              {{ states[filter_domain] | map(attribute='entity_id') | list }}
            {% else %}
              {{ target_entities | list }}
            {% endif %}
      - variables:
          result: >-
            {% import 'zenos_ai/zen_query.jinja' as zen %} {{ zen.zen_filter(filter_json,
            auto_base_list) }}
      - choose:
          - conditions:
              - condition: template
                value_template: "{{ log_result }}"
            sequence:
              - data:
                  name: ZQ-1 FILTER
                  message: "{{ filter_json }}"
                action: logbook.log
              - data:
                  name: ZQ-1 BASESET
                  message: |
                    {% if target_entities | count == 0 and filter_domain %}
                      Auto-built base list from domain '{{ filter_domain }}':
                      {{ auto_base_list }}
                    {% else %}
                      Provided target entities:
                      {{ auto_base_list }}
                    {% endif %}
                action: logbook.log
              - data:
                  name: ZQ-1 RESULT
                  message: "{{ result }}"
                action: logbook.log
      - choose:
          - conditions:
              - condition: template
                value_template: "{{ emit_event }}"
            sequence:
              - data:
                  component: dojo_query
                  severity: info
                  kind: query
                  summary: ZQ-1 filter applied
                  metadata:
                    filter: "{{ parsed_filter }}"
                    baselist_count: "{{ auto_base_list | count }}"
                    result_count: "{{ result | from_json | count }}"
                    domain: "{{ filter_domain }}"
                action: script.zen_dojotools_event_emitter
      - variables:
          final:
            status: ok
            domain: "{{ filter_domain }}"
            baselist: "{{ auto_base_list }}"
            result: "{{ result }}"
      - stop: Return query result
        response_variable: final
