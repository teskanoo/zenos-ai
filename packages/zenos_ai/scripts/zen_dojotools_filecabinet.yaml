script:
  zen_dojotools_filecabinet:
    sequence:
      - variables:
          routing_status: init
          normalized_label_targets: "{{ [] }}"
          resolved_label_drawers: "{{ [] }}"
          resolved_label_entities: "{{ [] }}"
          label_input_list: "{{ [] }}"
          read_volume: "{{ {} if false else {} }}"
          force_action: "{{ force_action | default(false) }}"
          action_type: "{{ action_type | default('help') }}"
          volume_entity: >-
            {% set _veid = volume_entity_id | default('') %} {% if _veid is string
            %}
              {{ _veid }}
            {% elif _veid is iterable and not _veid is string and _veid | length > 0
            %}
              {{ _veid[0] }}
            {% else %}
              ''
            {% endif %}
          drawer_input_raw: |-
            {% set k = key | default('') %} {% if k is string %}
              {{ k }}
            {% elif k is iterable and not k is string %}
              {{ k }}
            {% else %}
              ''
            {% endif %}
          drawer_list: >
            {% set raw = drawer_input_raw %} {% if raw is sequence and not raw is
            string %}
              {{ raw | map('string') | map('trim') | map('lower') | map('slugify') | unique | list }}
            {% elif raw is string %}
              {# Split on commas or newlines if necessary #}
              {% set parts = raw | replace('\n', ',') | regex_findall('[^,]+') %}
              {{ parts | map('string') | map('trim') | map('lower') | map('slugify') | unique | list }}
            {% else %}
              []
            {% endif %}
          drawer_count: "{{ drawer_list | length }}"
          single_drawer: >-
            {{ drawer_list[0] if drawer_list|length == 1 and drawer_list[0] not in
            ['', None] else '' }}
          raw_value: "{{ value | default('') }}"
          label_input: "{{ label_input | default('') }}"
          label_targets: "{{ label_targets | default('') }}"
          set_timestamp: "{{ set_timestamp | default(false) }}"
          protect_write: "{{ protect_write | default(true) }}"
          now_iso: "{{ now().isoformat() }}"
          is_create: "{{ action_type == 'create' }}"
          is_update: "{{ action_type == 'update' }}"
          is_read: "{{ action_type == 'read' }}"
          is_delete: "{{ action_type == 'delete' }}"
          is_help: "{{ action_type == 'help' }}"
          initial_volume_raw: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
          initial_volume: >-
            {% if initial_volume_raw is mapping %}{{ initial_volume_raw }}{% else
            %}{}{% endif %}
          key_exists_initial: "{{ (single_drawer != '') and (single_drawer in initial_volume) }}"
          prewrite_volume_raw: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
          prewrite_volume: >-
            {% if prewrite_volume_raw is mapping %}{{ prewrite_volume_raw }}{% else
            %}{}{% endif %}
          prettify_json_on_fail: "{{ prettify_json_on_fail | default(false) }}"
          label_raw: "{{ label_targets | default('') }}"
          resolved_label_targets: |-
            {{
              (label_raw
                | replace('\n', ',')
                | regex_findall('[^,]+')
                | map('trim')
                | map('lower')
                | list)
            }}
          label_index_map: |-
            {{
              (read_volume.get('_label_index', {}).get('value', {})
                  if read_volume is mapping else {})
            }}
          resolved_drawers: >-
            {%- set targets = resolved_label_targets if resolved_label_targets is
            sequence else [] -%}
    
            {%- set idx = label_index_map if label_index_map is mapping else {} -%}
    
    
            {%- set ns = namespace(accum=[]) -%}
    
    
            {# Build one merged list of drawers without using append() #}
    
            {%- for t in targets %}
              {%- set arr = idx.get(t, []) %}
    
              {# Normalize arr into clean list #}
              {%- if arr is mapping %}
                {%- set arr = arr.keys() | list %}
              {%- elif arr is iterable and not arr is string %}
                {%- set arr = arr | list %}
              {%- elif arr not in [none, ''] %}
                {%- set arr = [arr] %}
              {%- else %}
                {%- set arr = [] %}
              {%- endif %}
    
              {# Functional merge — no append — safe union #}
              {%- set ns.accum = (ns.accum + arr) | unique | list %}
            {%- endfor %}
    
            {%- if ns.accum | length == 0 -%}
              {{ [] }}
            {%- else -%}
              {{ ns.accum }}
            {%- endif %}
          is_label_mode: |-
            {{
              (resolved_label_targets | length > 0)
            }}
          current_label_index_raw: >-
            {%- set idx = initial_volume.get('_label_index', {}) %} {%- set val =
            idx.get('value') %} {%- if val is mapping %}
              {{ val }}
            {%- elif val is sequence %}
              {%- set mapped = {} -%}
              {%- for label in val if label is string -%}
                {%- set mapped = mapped | combine({ label: [] }) -%}
              {%- endfor -%}
              {{ mapped }}
            {%- else %}
              {} 
            {%- endif %}
          current_label_index: >-
            {%- import 'zenos_ai/library_index.jinja' as library_index -%} {{
            library_index.normalize_label_index(current_label_index_raw) }}
          parsed_value: >-
            {% set _v = raw_value | trim %} {% set error = none %} {% set parsed =
            none %} {% if _v == '' %}
              {% set error = "Write failed: Input value is blank." %}
            {% else %}
              {% set temp = _v %}
              {% set try_json = false %}
              {% if temp[:1] in ['{', '['] or temp in ['true', 'false', 'null'] %}
                {% set try_json = true %}
              {% elif temp | regex_match('^-?\\d+$') %}
                {% set try_json = true %}
              {% endif %}
              {% if try_json %}
                {% set parsed = temp | from_json %}
                {% if parsed is none %}
                  {% set error = "Write failed: Input value is not valid JSON. Please reformat using proper JSON syntax (e.g., escaped quotes, valid brackets)." %}
                {% endif %}
              {% else %}
                {% set js = temp
                  | replace('\\', '\\\\')
                  | replace('"', '\\"')
                  | replace('\r', '\\r')
                  | replace('\n', '\\n')
                  | replace('\t', '\\t')
                %}
                {% set wrapped = '"' ~ js ~ '"' %}
                {% set parsed = wrapped | from_json %}
                {% if parsed is none %}
                  {% set error = "Write failed: Could not coerce string to JSON—possibly invalid input or encoding." %}
                {% endif %}
              {% endif %}
            {% endif %} {% if error %}
              {{ error }}
            {% else %}
              {{ parsed }}
            {% endif %}
          parsed_entity_labels: |-
            {% if is_create or is_update %}
              {% if label_input is string %}
                {% set s = label_input | replace('\n', ',') %}
                {{
                  (
                    s
                    | regex_findall('[^,]+')
                    | map('trim')
                    | map('lower')
                    | map('slugify')
                    | select('string')
                    | sort
                    | list
                  )
                }}
              {% elif label_input is sequence %}
                {{
                  (
                    label_input
                    | map('trim')
                    | map('lower')
                    | map('slugify')
                    | select('string')
                    | sort
                    | list
                  )
                }}
              {% else %}
                []
              {% endif %}
            {% else %}
              []
            {% endif %}
          all_system_labels: |-
            {% if is_create or is_update %}
              {{ labels() | map('lower') | sort | list }}
            {% else %}
              []
            {% endif %}
          dropped_labels: >-
            {{ parsed_entity_labels | reject('in', all_system_labels) | sort | list
            }}
          accepted_entity_labels: >-
            {{ parsed_entity_labels | select('in', all_system_labels) | sort | list
            }}
          updated_label_index: |-
            {% if (is_create | default(false)) or (is_update | default(false)) %}
              {%- set vol =
                    (prewrite_volume if prewrite_volume is mapping else initial_volume)
              -%}
              {%- set current_index = vol.get('_label_index', {}).get('value', {}) -%}
              {%- set current = current_index if current_index is mapping else {} -%}
    
              {%- set drawer_name = single_drawer | lower | slugify -%}
              {%- set new_labels =
                    (accepted_entity_labels
                      | map('string')
                      | map('lower')
                      | map('slugify')
                      | list)
              -%}
    
              {%- set acc = namespace(val = dict(current)) -%}
              {%- for label in new_labels %}
                {%- set entry = acc.val.get(label) %}
                {%- set existing =
                      (entry if entry is iterable and not entry is string else
                       [entry] if entry not in [None, ''] else [])
                -%}
                {%- set acc.val = acc.val | combine({
                      label: (existing + [drawer_name]) | unique | list
                    })
                -%}
              {%- endfor %}
    
              {{ acc.val }}
            {% else %}
              {}
            {% endif %}
          extended_label_index: >-
            {%- set raw = initial_volume.get('_label_index', {}).get('value') -%}
            {%- set index = {} -%}
    
            {% if raw is mapping %}
              {# Full nested label index (expected case) #}
              {% for _label, drawers in raw.items() %}
                {%- set label = _label | lower | slugify -%}
    
                {# Normalize drawers to a clean list #}
                {%- if drawers is mapping %}
                  {# A dict of drawers → copy keys only, normalized #}
                  {%- set clean = drawers.keys() | list -%}
    
                {%- elif drawers is iterable and not drawers is string %}
                  {# Could be list, tuple, generator → normalize #}
                  {%- set clean = drawers | list -%}
    
                {%- else %}
                  {# Single string or other scalar #}
                  {%- set clean = [drawers] -%}
                {%- endif %}
    
                {# Force all drawers to become lowercase-slugified names #}
                {%- set clean = clean
                                | map('string')
                                | map('lower')
                                | map('slugify')
                                | list
                 -%}
    
                {# Remove duplicates, ensure real list #}
                {%- set clean = clean | unique | list -%}
    
                {%- set index = index | combine({ label: clean }) -%}
              {% endfor %}
    
            {% elif raw is iterable and not raw is string %}
              {# Legacy format: ['label1','label2'] #}
              {% for _label in raw %}
                {%- set label = _label | lower | slugify -%}
                {%- set index = index | combine({ label: ['_unknown_drawer'] }) -%}
              {% endfor %}
    
            {% else %}
              {# Fallback: rebuild from drawers' meta #}
              {% for drawer, val in initial_volume.items() %}
                {%- set labels = [] -%}
                {% if val is mapping and 'meta' in val and val.meta is mapping %}
                  {%- set labels = val.meta.get('entity_labels', []) -%}
                {% elif val is mapping and 'entity_labels' in val %}
                  {%- set labels = val.get('entity_labels', []) -%}
                {% endif %}
    
                {% for _label in labels %}
                  {%- set label = _label | lower | slugify -%}
                  {%- set existing = index.get(label, []) -%}
                  {%- set index = index | combine({
                        label: (existing + [drawer]) 
                               | map('string')
                               | map('lower')
                               | map('slugify')
                               | unique
                               | list
                      })
                  -%}
                {% endfor %}
              {% endfor %}
            {% endif %}
    
            {{ index }}
          new_entry: |-
            {% if is_create or is_update %}
              {% set base = {'value': parsed_value} %}
              {% set with_ts = base | combine({'timestamp': now_iso}) if set_timestamp else base %}
              {% set full = with_ts | combine({'meta': {'entity_labels': accepted_entity_labels | list}}) if accepted_entity_labels | length > 0 else with_ts %}
              {{ full }}
            {% else %}
              {}
            {% endif %}
          new_volume: |-
            {% if is_create or is_update %}
              {% set vol = state_attr(volume_entity, 'variables') | default(initial_volume, true) %}
              {{ vol | combine({
                (single_drawer): new_entry,
                '_label_index': {
                  'value': updated_label_index,
                  'timestamp': now_iso
                }
              }, recursive=true) }}
            {% else %}
              {{ initial_volume }}
            {% endif %}
          initial_norm: |
            {{ initial_volume }}
          current_norm: |
            {{
              (
                state_attr(volume_entity, 'variables')
                | default({}, true)
              )
            }}
          volume_unmodified: |
            {{
              (not protect_write)
              or
              (initial_norm == current_norm)
            }}
          cabinet_volumeinfo: >-
            {% set info = initial_volume.get('AI_Cabinet_VolumeInfo', {}) %} {% if
            info is mapping and info.get('value') is mapping %}
              {{ info.get('value') }}
            {% else %}
              {}
            {% endif %}
          zen_relationships: >-
            {% set z = initial_volume.get('_zen_relationships', {}) %} {% if z is
            mapping and z.get('value') is mapping %}
              {{ z.get('value') }}
            {% else %}
              {}
            {% endif %}
          is_create_new: |-
            {{
              action_type == 'create'
              and single_drawer != ''
              and not key_exists_initial
            }}
          is_force_update_new: |-
            {{
              action_type == 'update'
              and single_drawer != ''
              and not key_exists_initial
              and force_action
            }}
          is_force_create_over_existing: |-
            {{
              action_type == 'create'
              and single_drawer != ''
              and key_exists_initial
              and force_action
            }}
          is_create_path: |-
            {{
              is_create_new
              or is_force_update_new
              or is_force_create_over_existing
            }}
          is_update_path: |-
            {{
              is_update and key_exists_initial
            }}
          is_write_action: |-
            {{
              action_type in ['create','update','delete','move','copy']
            }}
      - choose:
          - conditions:
              - alias: Error - Fatal JSON Parsing
                condition: template
                value_template: |+
                  {%- set err_str =
                        parsed_value
                        if parsed_value is string
                        else (parsed_value.get('error','') | string if parsed_value is mapping else '')
                  -%}
                  {{
                    (action_type not in ['manifest', 'read', 'delete', 'move', 'copy', 'help'])
                    and (err_str[:12] == 'Write failed')
                  }}

            sequence:
              - action: system_log.write
                data:
                  level: error
                  message: >
                    ZenDojoTools FileCabinet: FATAL — JSON parse error, write
                    aborted. Key: {{ single_drawer }} | Volume: {{ volume_entity }}
                    Parsed Value: {{ parsed_value }}
              - variables:
                  fatal_response: |-
                    {{
                      {
                        "status": "error",
                        "failure": "json_parse_error",
                        "volume_entity": volume_entity,
                        "drawer": single_drawer,
                        "parsed_value": parsed_value
                      } | tojson
                    }}
              - stop: JSON Parse Failure
                response_variable: fatal_response
      - choose:
          - conditions:
              - condition: template
                value_template: |
                  {{ action_type in ['create','update','delete','move','copy'] }}
                alias: Is a 'write' action
            sequence:
              - variables:
                  vol_health: "{{ state_attr(volume_entity, 'health') or {} }}"
                  h_status: "{{ vol_health.get('status','') }}"
                  h_mismatch: "{{ vol_health.get('guid_mismatch', false) }}"
                  h_writeable: "{{ vol_health.get('writeable', true) }}"
                  h_storage_warning: "{{ vol_health.get('storage_warning', false) }}"
                  health_blocked: |
                    {{
                      (h_status == 'error')
                      or h_mismatch
                      or (not h_writeable)
                      or (h_storage_warning and not force_action)
                    }}
              - choose:
                  - conditions:
                      - condition: template
                        value_template: "{{ health_blocked }}"
                        alias: "Error: Not Healthy"
                    sequence:
                      - variables:
                          final_response:
                            status: error
                            message: "Write blocked: Volume not healthy."
                            health_snapshot:
                              status: "{{ h_status }}"
                              mismatch: "{{ h_mismatch }}"
                              writeable: "{{ h_writeable }}"
                              storage_warning: "{{ h_storage_warning }}"
                              force_action: "{{ force_action }}"
                      - stop: Health-blocked write
                        response_variable: final_response
                  - conditions:
                      - alias: Multi Drawer
                        condition: template
                        value_template: |
                          {{ drawer_count > 1 }}
                    sequence:
                      - variables:
                          final_response:
                            status: error
                            message: "Write blocked: Multi Drawer Write not allowed."
                            drawer_count: "{{ drawer_count }}"
                      - stop: Multi-Drawer blocked write
                        response_variable: final_response
            alias: Is a 'Write'-type (include delete)
      - choose:
          - conditions:
              - alias: Error - Create Update, Drawer or Value Missing
                condition: template
                value_template: >-
                  {{ action_type in ['create','update'] and (single_drawer == ''  or
                  raw_value == '') }}
            sequence:
              - variables:
                  final_response:
                    status: error
                    message: >-
                      For '{{ action_type }}', you must supply both 'key' and
                      'value'.
              - stop: Missing key/value
                response_variable: final_response
          - conditions:
              - alias: Error - Delete, Drawer Missing
                condition: template
                value_template: "{{ action_type == 'delete' and single_drawer == '' }}"
            sequence:
              - variables:
                  final_response:
                    status: error
                    message: For 'delete', you must supply a 'key'.
              - stop: Missing drawer for delete
                response_variable: final_response
          - conditions:
              - alias: Error - Update, Drawer does not exist
                condition: template
                value_template: >-
                  {{ action_type == 'update' and not key_exists_initial and not
                  force_action }}
            sequence:
              - variables:
                  final_response:
                    status: error
                    message: "Cannot update: drawer '{{ single_drawer }}' does not exist."
              - stop: Drawer not found
                response_variable: final_response
          - conditions:
              - alias: Error — Create, Drawer Exists and Not Force_Action
                condition: template
                value_template: |-
                  {{
                    action_type == 'create'
                    and single_drawer  != ''
                    and key_exists_initial
                    and not force_action
                  }}
            sequence:
              - variables:
                  final_response:
                    status: error
                    message: >-
                      Cannot create: drawer '{{ single_drawer }}' exists. Use Update
                      or retry with override approval using force_action. (Will be
                      logged)
              - stop: Drawer Exists and not force_action
                response_variable: final_response
          - conditions:
              - condition: template
                value_template: "{{ action_type == 'help' }}"
                alias: Help
            sequence:
              - variables:
                  final_response:
                    status: info
                    message: Zen DojoTools File Cabinet Help
                    actions:
                      manifest: >-
                        Returns the full Volume Manifest. This lists every volume
                        and its mounted state. If an invalid volume_entity or drawer
                        is supplied, the controller may fall back to the Manifest.
                        If you unexpectedly receive a Manifest, your request
                        parameters were invalid.
                      create: >-
                        Optional: set_timestamp, protect_write, label_input.
                        Requires a single 'drawer' and a 'value'. Drawer must NOT
                        already exist unless force_action is set. Writes replace the
                        ENTIRE drawer as a full overwrite. 'value' must be valid
                        JSON; the engine will parse it and return an error if the
                        JSON is malformed.
                      read: |-
                        manifest: >-
                          Set 'volume_entity' to '*'
                          Returns the Volume Manifest (all volumes).
                        volume: >-
                          directory: >-
                            Set 'volume_entity' to your volume sensor
                            Set 'drawer' to '', None, or '*'
                            Returns the directory listing of drawers inside the volume.
                          content: >-
                            Set 'volume_entity' to your volume sensor
                            Set 'drawer' to a single valid drawer
                            Returns the drawer’s stored JSON content.
                          special: >-
                            Use 'label_targets' to return only drawers that match the labels.
                            Useful for filtered reads across a volume.
                      update: >-
                        Requires a single 'drawer' and a 'value'. Drawer must
                        already exist unless force_action is set. Writes replace the
                        ENTIRE drawer; no partial updates. 'value' must be valid
                        JSON; the controller will parse and error on failure. With
                        force_action, a non-existent drawer will be silently created
                        instead of returning an error.
                      delete: >-
                        Requires a single 'drawer'. Removes the drawer entirely from
                        the volume. Prunes label index entries associated with that
                        drawer.
                      copy: >-
                        Requires a source 'drawer' (only the FIRST drawer in the
                        list is used; additional entries are ignored). Also requires
                        'destination_drawer' and 'destination_cabinet'. Copies the
                        drawer content to the destination cabinet. Destination
                        drawer must not exist unless force_action is set. If
                        force_action is true, destination drawer is overwritten.
                      move: >-
                        Same requirements and behavior as Copy. After a successful
                        copy to the destination, the source drawer is deleted.
                      help: Returns this help block.
                    about:
                      version: 3.9.0
                      branch: RC1
                      manual: |-
                        summary: >
                          The Zen DojoTools File Cabinet is the primary engine for managing
                          structured data inside volumes. A volume is a named container, and each
                          volume holds multiple drawers. Each drawer contains a JSON object along
                          with metadata, indexes, and labels that make the data discoverable and
                          machine-friendly.
    
                          Reads can operate in three modes: directory-level (list drawers),
                          content-level (return a single drawer’s JSON), or label-filtered
                          (return only drawers matching one or more labels). Writes are always
                          full-drawer overwrites, ensuring strong consistency.
    
                          Volumes are optimized for clean separation of contexts. Use
                          read-optimized drawers for stable hierarchical data and write-optimized
                          drawers for fast-changing state like game loops or automation
                          checkpoints. Labeling drawers enables powerful cross-volume discovery
                          and indexing, ensuring your data remains searchable as the system grows.
    
                          The volume index performs table-scan discovery across all accessible
                          volumes. Drawer-level metadata enriches the model and supports decision
                          making, keeping information organized, consistent, and ready for both
                          Friday and the Monastery.
    
                          Use this tool as your foundation for any structured data in ZenOS-AI.
                          It is stable, cabinet-aware, label-aware, index-safe, and designed for
                          both reliability and performance.
                        author: person.friday
                        date: 6/8/2025
                    defaults:
                      protect_write: true
              - stop: Returning help
                response_variable: final_response
          - conditions:
              - alias: Read by Label
                condition: template
                value_template: |
                  {{ action_type != 'manifest'
                      and
                    (label_targets | default('') | trim | length > 0)
                  }}
            sequence:
              - variables:
                  always_hide_drawers:
                    - AI_Cabinet_VolumeInfo
                  read_volume: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
                  vol: "{{ read_volume if read_volume is mapping else {} }}"
                  normalized_label_targets: |-
                    {{
                      (
                        (label_targets | default('') | replace('\n', ','))
                        | regex_findall('[^,]+')
                        | map('trim')
                        | map('lower')
                        | map('slugify')
                        | list
                      )
                    }}
                  label_index: |-
                    {{
                      (
                        vol.get('_label_index', {}).get('value', {})
                        if vol is mapping else {}
                      )
                    }}
                  resolved_label_drawers: |-
                    {# Step 1: detect bad python literal #}
                    {% set is_python_literal =
                      (label_index is string)
                      and label_index|trim is match('^\\{.*:.*\\}$')
                      and ("'" in label_index)
                      and ('"' not in label_index)
                    %}
    
                    {# Step 2: fix it if needed #}
                    {% if is_python_literal %}
                      {% set json_str = label_index
                        | replace("'", '"')
                        | replace("None", "null")
                        | replace("True", "true")
                        | replace("False", "false")
                      %}
                      {% set idx = json_str | from_json %}
                    {% elif label_index is string %}
                      {% set idx = label_index | from_json %}
                    {% else %}
                      {% set idx = label_index %}
                    {% endif %}
    
                    {% set targets = (normalized_label_targets | list) %}
                    {% set ns = namespace(out=[]) %}
    
                    {# Iterate through targets #}
                    {% for t in targets %}
                      {% set raw_arr = idx[t] | default('__MISS__') %}
    
                      {# normalize arr #}
                      {% if raw_arr is mapping %}
                        {% set arr = raw_arr.keys() | list %}
                      {% elif raw_arr is iterable and raw_arr is not string and raw_arr != '__MISS__' %}
                        {% set arr = raw_arr | list %}
                      {% elif raw_arr not in [none, '', '__MISS__'] %}
                        {% set arr = [raw_arr] %}
                      {% else %}
                        {% set arr = [] %}
                      {% endif %}
    
                      {# merge #}
                      {% set ns.out = (ns.out + arr) | unique | list %}
                    {% endfor %}
    
                    {{ ns.out }}
                  is_label_mode: "{{ normalized_label_targets | length > 0 }}"
                  read_payload: |-
                    {% set vol = read_volume if read_volume is mapping else {} %}
                    {% if vol|length == 0 %}
                      {{ {"error": "Volume attribute missing or empty."} }}
                    {% else %}
                      {% set targets = normalized_label_targets %}
                      {% set drawers = resolved_label_drawers %}
                      {% set has_targets = targets|length > 0 %}
                      {% if has_targets %}
                        {% set ns = namespace(out={}) %}
                        {% for d in drawers %}
                          {% if d in vol and d not in always_hide_drawers and not (d[:1] in ['_', '.']) %}
                            {% set ns.out = ns.out | combine({ d: vol[d] }) %}
                          {% endif %}
                        {% endfor %}
                        {{
                          {
                            "mode": "label",
                            "label_targets": targets,
                            "resolved_drawers": drawers,
                            "count": ns.out|length,
                            "drawers": ns.out,
                            "message": (
                              "No drawers found for requested labels."
                              if ns.out|length == 0
                              else "OK"
                            )
                          } 
                        }}
                      {% else %}
                        {{ {
                          "error": "Label mode requested but no labels found.",
                          "label_targets": targets
                        } }}
                      {% endif %}
                    {% endif %}
              - variables:
                  final_response:
                    status: >-
                      {{ 'error' if (read_payload is string and read_payload[:8] ==
                      '{"error"') else 'success' }}
                    message: >-
                      {% if read_payload is string and read_payload[:8] ==
                      '{"error"' %}
                        There was a problem reading from the volume.
                      {% else %}
                        Read succeeded.
                      {% endif %}
                    result: "{{ read_payload }}"
              - stop: Read complete
                response_variable: final_response
          - conditions:
              - condition: template
                value_template: |-
                  {{ action_type != 'manifest'
                      and ( drawer_list | length > 1 ) }}
            sequence:
              - variables:
                  multi_read_result: |-
                    {%- set ns = namespace(out={}) -%}
                    {%- for d in drawer_list -%}
                      {%- if d not in ['', None, '*'] -%}
                        {%- set entry = initial_volume.get(d, {}) -%}
                        {%- set ns.out = ns.out | combine({ d: entry }) -%}
                      {%- endif -%}
                    {%- endfor -%}
                    {{ ns.out }}
              - stop: Multi-drawer content read
                response_variable: multi_read_result
            alias: Multi drawer content read
          - conditions:
              - alias: Directory - Read all drawers in volume
                condition: template
                value_template: |
                  {{ action_type == 'read'
                     and ((label_targets | trim) == '')
                     and (volume_entity not in ['', '*', None])
                     and (single_drawer in ['', None, '*']) }}
            sequence:
              - variables:
                  ignore_label_prefixes:
                    - _
                    - .
                  always_hide_drawers:
                    - AI_Cabinet_VolumeInfo
                  read_volume: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
                  raw_drawers: >-
                    {% if read_volume is mapping %}{{ read_volume.keys() | list }}{%
                    else %}[]{% endif %}
                  read_label_index: |-
                    {% if read_volume %}
                      {{ read_volume.get('_label_index', {}).get('value', []) }}
                    {% else %}
                      []
                    {% endif %}
                  read_filtered_manifest: >-
                    {%- import 'zenos_ai/library_index.jinja' as library_index -%}
    
                    {%- set cabs_json = library_index.parse_index_command('AI Data
                    Storage Cabinet') -%}
    
                    {%- set fixed_json = cabs_json | replace("['", '["')  |
                    replace("']", '"]') | replace("', '", '", "') | trim %}
    
                    {%- set cabs = fixed_json | from_json -%}
    
                    {%- set sensors = states['sensor'] | map(attribute='entity_id')
                    | list -%}
    
                    {%- set fcabs = intersect(sensors, cabs) -%}
    
    
                    {%- set ns = namespace(filtered={}) %}
    
                    {%- for cab_entity in fcabs %}
                      {%- set variables = state_attr(cab_entity, 'variables') %}
                      {%- if variables and variables.get('AI_Cabinet_VolumeInfo') and variables['AI_Cabinet_VolumeInfo'].get('value') %}
                        {%- set cab_id = variables['AI_Cabinet_VolumeInfo']['value'].get('id', cab_entity) %}
                        {%- set ns.filtered = ns.filtered | combine({
                          (cab_entity): variables['AI_Cabinet_VolumeInfo']['value']
                        }) %}
                      {%- endif %}
                    {%- endfor %}
    
                    {{ ns.filtered }}
                  parsed_key: "{{ single_drawer | default('', true) | trim | lower }}"
                  initial_volume: "{{ read_volume if read_volume is mapping else {} }}"
                  read_payload: >-
    
                    {# Ensure read_volume is a mapping; else fallback to empty dict
                    #}
    
                    {% set safe_read_volume = read_volume if read_volume is mapping
                    else {} %}
    
    
                    {% if safe_read_volume | length == 0 %}
                      {{ {'error': 'Volume attribute missing or empty.'} }}
                    {% elif parsed_key in ['', '*'] %}
                      {%- set raw_drawers = safe_read_volume.keys() | list | default([]) %}
                        {%- set filtered_drawers_ns = namespace(items=[]) %}
                      {%- for d in raw_drawers %}
                        {%- if d not in always_hide_drawers and not (d[:1] == '_' or d[:1] == '.') %}
                          {%- set val = safe_read_volume.get(d, {}) %}
                          {%- set val_value = val.get('value') if val is mapping else {} %}
                          {%- if val is mapping and val_value is mapping and val_value.get('mount_point', false) %}
                            {%- set mp_target = (
                                val_value.get('target_entity_id')
                                if val_value.get('target_entity_id')
                                else val_value.get('target_volume_id')
                                if val_value.get('target_volume_id')
                                else '?'
                              ) -%}
                            {%- set drawer_name = d ~ ' [mount:' ~ mp_target ~ ']' %}
                          {%- else %}
                            {%- set drawer_name = d %}
                          {%- endif %}
                          {%- set filtered_drawers_ns.items = filtered_drawers_ns.items + [drawer_name] %}
                        {%- endif %}
                      {%- endfor %}
                      {%- set drawer_list = filtered_drawers_ns.items %}
    
                      {{
                        {
                          'drawers': drawer_list,
                          'label_index': read_label_index
                        } | tojson
                      }}
                    {% endif %}
              - variables:
                  final_response:
                    status: >-
                      {{ 'error' if (read_payload is string and read_payload[:8] ==
                      '{"error"') else 'success' }}
                    message: >-
                      {% if read_payload is string and read_payload[:8] ==
                      '{"error"' %}
                        There was a problem reading drawers in the volume.
                      {% else %}
                        Directory read succeeded.
                      {% endif %}
                    result: "{{ read_payload }}"
              - stop: Volume directory read complete
                response_variable: final_response
          - conditions:
              - alias: Read
                condition: template
                value_template: |+
                  {% set is_direct_read =
                       (action_type == 'read')
                       and (volume_entity not in [None, '', '*'])
                       and (single_drawer not in [None, '', '*'])
                  %}
    
                  {% set has_labels = normalized_label_targets is iterable
                                      and (normalized_label_targets | length) > 0 %}
    
                  {% set is_label_read =
                       (action_type == 'read')
                       and has_labels
                  %}
    
                  {{ is_direct_read or is_label_read }}

            sequence:
              - variables:
                  ignore_label_prefixes:
                    - _
                    - .
                  always_hide_drawers:
                    - AI_Cabinet_VolumeInfo
                  read_volume: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
                  parsed_key: "{{ single_drawer | default('', true) | trim | lower }}"
                  vol: "{{ read_volume if read_volume is mapping else {} }}"
                  label_index: |-
                    {{
                      (
                        vol.get('_label_index', {}).get('value', {})
                        if vol is mapping else {}
                      )
                    }}
                  read_payload: |-
                    {% if vol | length == 0 %}
                      {{ {"error": "Volume attribute missing or empty."} }}
                    {% else %}
                      {# --------------------------------------------------
                         CASE 0: MULTI-DRAWER READ
                         -------------------------------------------------- #}
                      {% if drawer_count > 1 %}
                        {% set ns = namespace(out={}) %}
                        {% for d in drawer_list %}
                          {% if d in vol %}
                            {% set ns.out = ns.out | combine({ d: vol[d] }) %}
                          {% else %}
                            {% set ns.out = ns.out | combine({ d: "__NOT_FOUND__" }) %}
                          {% endif %}
                        {% endfor %}
                        {{ ns.out }}
                      {% else %}
    
                        {# --------------------------------------------------
                           CASE 1: DIRECTORY LISTING ("", "*")
                           -------------------------------------------------- #}
                        {% if parsed_key in ['', '*'] %}
                          {%- set ns_draw = namespace(drawers=[]) -%}
                          {%- for d in vol.keys() | list -%}
                            {%- if d not in always_hide_drawers and not (d[:1] in ['_', '.']) -%}
                              {%- set ns_draw.drawers = ns_draw.drawers + [d] -%}
                            {%- endif -%}
                          {%- endfor -%}
                          {{ {"drawers": ns_draw.drawers, "label_index": label_index} }}
    
                        {# --------------------------------------------------
                           CASE 2: DIRECT DRAWER READ
                           -------------------------------------------------- #}
                        {% elif parsed_key in vol %}
                          {{ {parsed_key: vol[parsed_key]} | tojson }}
    
                        {# --------------------------------------------------
                           CASE 3: NOT FOUND
                           -------------------------------------------------- #}
                        {% else %}
                          {{ {"error": "Requested drawer not found in volume."} }}
                        {% endif %}
    
                      {% endif %}
    
                    {% endif %}
              - variables:
                  final_response:
                    status: >-
                      {{ 'error' if (read_payload is string and read_payload[:8] ==
                      '{"error"') else 'success' }}
                    message: >-
                      {% if read_payload is string and read_payload[:8] ==
                      '{"error"' %}
                        There was a problem reading from the volume.
                      {% else %}
                        Read succeeded.
                      {% endif %}
                    result: "{{ read_payload }}"
              - stop: Read complete
                response_variable: final_response
          - conditions:
              - alias: Manifest - Read Volume( '', '*' )
                condition: template
                value_template: |2
                    {{
                      action_type == 'manifest'
                      or (
                        action_type == 'read'
                        and (label_targets | trim) == ''
                        and (volume_entity in ['', '*', None])
                      )
                    }}
            sequence:
              - action: script.zen_dojotools_manifest
                metadata: {}
                data:
                  show_hidden_volumes: "{{ show_hidden_volumes }}"
                response_variable: final_response
              - stop: Manifest read complete
                response_variable: final_response
          - conditions:
              - alias: Create (or Update when Drawer not Exist and Force)
                condition: template
                value_template: |-
                  {{
                     is_create_new
                     or is_force_update_new
                     or is_force_create_over_existing
                  }}
            sequence:
              - choose:
                  - conditions:
                      - condition: template
                        value_template: |2-
                            {{
                              protect_write
                              and not force_action
                              and not volume_unmodified
                            }}
                    sequence:
                      - variables:
                          final_response:
                            status: error
                            message: "Protected write blocked: volume was modified. Retry."
                      - stop: Concurrent modification
                        response_variable: final_response
              - event: set_variable_legacy
                event_data:
                  key: "{{ single_drawer }}"
                  value: "{{ new_entry.value }}"
                  set_timestamp: "{{ set_timestamp }}"
                  volume_entity: "{{ volume_entity }}"
              - choose:
                  - conditions:
                      - condition: template
                        value_template: "{{ accepted_entity_labels | length > 0 }}"
                        alias: Valid Labels
                    sequence:
                      - alias: Update the index
                        event: set_variable_legacy
                        event_data:
                          key: _label_index
                          value: "{{ updated_label_index }}"
                          set_timestamp: true
                          volume_entity: "{{ volume_entity }}"
              - alias: Read after Write Verification
                wait_template: |-
                  {% set vol = state_attr(volume_entity, 'variables') %}
                  {% if vol is mapping %}
                    {% set entry = vol.get(single_drawer) %}
                    {{ entry is mapping }}
                  {% else %}
                    false
                  {% endif %}
                timeout: "00:00:02"
                continue_on_timeout: true
              - variables:
                  verify_volume: >-
                    {% set raw = state_attr(volume_entity, 'variables') %} {% if raw
                    is mapping %}
                      {{ raw }}
                    {% else %}
                      {}
                    {% endif %}
                  verify_entry: |-
                    {% if verify_volume is mapping %}
                      {{ verify_volume.get(single_drawer, {}) }}
                    {% else %}
                      {}
                    {% endif %}
                  write_verified: |-
                    {{
                      verify_entry is mapping
                      and verify_entry.get('value') == new_entry['value']
                    }}
              - variables:
                  final_response:
                    status: "{{ 'success' if write_verified else 'warning' }}"
                    message: |-
                      {% if write_verified %}
                        Created drawer '{{ single_drawer }}' (verification confirmed).
                      {% else %}
                        Created drawer '{{ single_drawer }}' (value written but verification delayed).
                      {% endif %}
                    entry:
                      drawer: "{{ single_drawer }}"
                      value: "{{ new_entry.value }}"
                      timestamp: >-
                        {{ new_entry.timestamp if new_entry.timestamp is defined
                        else None }}
                    verification:
                      confirmed: "{{ write_verified }}"
                    warnings: |-
                      {% if dropped_labels | length > 0 %}
                        Warning: {{ dropped_labels | length }} ignored label(s): {{ dropped_labels }}
                      {% else %}
                        None
                      {% endif %}
              - stop: Create fired
                response_variable: final_response
          - conditions:
              - alias: Update
                condition: template
                value_template: >
                  {{ action_type == 'update' and key_exists_initial and not
                  is_force_update_new }}
            sequence:
              - choose:
                  - conditions:
                      - alias: "Error - Concurrent Modification Blocked: Modified"
                        condition: template
                        value_template: |2
                            {{
                              protect_write
                              and not force_action
                              and not volume_unmodified
                            }}
                    sequence:
                      - variables:
                          final_response:
                            status: error
                            message: "Protected write blocked: volume was modified. Retry."
                      - stop: Concurrent modification
                        response_variable: final_response
              - event: set_variable_legacy
                event_data:
                  key: "{{ single_drawer }}"
                  value: "{{ new_entry.value }}"
                  set_timestamp: "{{ set_timestamp }}"
                  volume_entity: "{{ volume_entity }}"
              - choose:
                  - conditions:
                      - condition: template
                        value_template: "{{ accepted_entity_labels | length > 0 }}"
                        alias: Valid Labels
                    sequence:
                      - alias: Update the Index
                        event: set_variable_legacy
                        event_data:
                          key: _label_index
                          value: "{{ updated_label_index }}"
                          set_timestamp: true
                          volume_entity: "{{ volume_entity }}"
              - alias: Read after Write Verification (update)
                wait_template: |-
                  {% set vol = state_attr(volume_entity, 'variables') %}
                  {% if vol is mapping %}
                    {% set entry = vol.get(single_drawer) %}
                    {{ entry is mapping }}
                  {% else %}
                    false
                  {% endif %}
                timeout: "00:00:02"
                continue_on_timeout: true
              - variables:
                  verify_volume: >-
                    {% set raw = state_attr(volume_entity, 'variables') %} {% if raw
                    is mapping %}
                      {{ raw }}
                    {% else %}
                      {}
                    {% endif %}
                  verify_entry: |-
                    {% if verify_volume is mapping %}
                      {{ verify_volume.get(single_drawer, {}) }}
                    {% else %}
                      {}
                    {% endif %}
                  write_verified: |-
                    {{
                      verify_entry is mapping
                      and verify_entry.get('value') == new_entry['value']
                    }}
              - variables:
                  final_response:
                    status: "{{ 'success' if write_verified else 'warning' }}"
                    message: |-
                      {% if write_verified %}
                        Updated drawer '{{ single_drawer }}' (verification confirmed).
                      {% else %}
                        Updated drawer '{{ single_drawer }}' (value written but verification delayed).
                      {% endif %}
                    entry:
                      drawer: "{{ single_drawer }}"
                      value: "{{ new_entry.value }}"
                      timestamp: >-
                        {{ new_entry.timestamp if new_entry.timestamp is defined
                        else None }}
                    verification:
                      confirmed: "{{ write_verified }}"
                    warnings: |-
                      {% if dropped_labels | length > 0 %}
                        Warning: {{ dropped_labels | length }} ignored label(s): {{ dropped_labels }}
                      {% else %}
                        None
                      {% endif %}
              - stop: Update fired
                response_variable: final_response
          - conditions:
              - condition: template
                value_template: "{{ action_type == 'delete' and key_exists_initial }}"
                alias: Delete
            sequence:
              - event: remove_variable_legacy
                event_data:
                  key: "{{ single_drawer }}"
                  volume_entity: "{{ volume_entity }}"
              - alias: Read after Delete Verification
                wait_template: >-
                  {% set vol = state_attr(volume_entity, 'variables') | default({},
                  true) %} {{ vol is mapping and (single_drawer not in vol) }}
                timeout: "00:00:01"
                continue_on_timeout: true
              - variables:
                  verify_volume: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
                  delete_verified: >-
                    {{ verify_volume is mapping and (single_drawer not in
                    verify_volume) }}
              - variables:
                  _index_src: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
                  _raw_index: |-
                    {% if _index_src is mapping %}
                      {{ _index_src.get('_label_index', {}).get('value', {}) }}
                    {% else %}
                      {}
                    {% endif %}
                  pruned_index: |-
                    {% if _raw_index is mapping %}
                      {# Build a cleaned copy with `single_drawer ` removed everywhere #}
                      {% set cleaned = {} %}
                      {% for label, drawers in _raw_index.items() %}
                        {% if drawers is mapping %}
                          {# Nested form: label -> {sub: [drawers]} #}
                          {% set kept_sub = {} %}
                          {% for sub, arr in drawers.items() %}
                            {% set al = arr if (arr is iterable and not arr is string) else [arr] %}
                            {% set cleaned_arr = al | reject('equalto', single_drawer ) | list %}
                            {% if cleaned_arr | length > 0 %}
                              {% set kept_sub = kept_sub | combine({ sub: cleaned_arr }) %}
                            {% endif %}
                          {% endfor %}
                          {% if kept_sub | length > 0 %}
                            {% set cleaned = cleaned | combine({ label: kept_sub }) %}
                          {% endif %}
                        {% elif drawers is iterable and not drawers is string %}
                          {# Flat list form: label -> [drawers] #}
                          {% set cleaned_list = drawers | reject('equalto', single_drawer ) | list %}
                          {% if cleaned_list | length > 0 %}
                            {% set cleaned = cleaned | combine({ label: cleaned_list }) %}
                          {% endif %}
                        {% else %}
                          {# Single value fallback #}
                          {% if drawers != single_drawer %}
                            {% set cleaned = cleaned | combine({ label: [drawers] }) %}
                          {% endif %}
                        {% endif %}
                      {% endfor %}
                      {{ cleaned }}
                    {% else %}
                      {}
                    {% endif %}
                  index_changed: "{{ pruned_index != _raw_index }}"
              - choose:
                  - conditions:
                      - condition: template
                        value_template: "{{ index_changed }}"
                        alias: Prune needed
                    sequence:
                      - event: set_variable_legacy
                        event_data:
                          key: _label_index
                          value: "{{ pruned_index }}"
                          set_timestamp: true
                          volume_entity: "{{ volume_entity }}"
                      - alias: Index prune verification
                        wait_template: >-
                          {% set vol = state_attr(volume_entity, 'variables') |
                          default({}, true) %} {% set raw = vol.get('_label_index',
                          {}).get('value') if vol is mapping else {} %} {% set found
                          = false %} {% if raw is mapping %}
                            {% for label, drawers in raw.items() %}
                              {% if drawers is mapping %}
                                {% for sub, arr in drawers.items() %}
                                  {% set al = arr if (arr is iterable and not arr is string) else [arr] %}
                                  {% if single_drawer in al %}{% set found = true %}{% endif %}
                                {% endfor %}
                              {% elif drawers is iterable and not drawers is string %}
                                {% if single_drawer in drawers %}{% set found = true %}{% endif %}
                              {% else %}
                                {% if drawers == single_drawer %}{% set found = true %}{% endif %}
                              {% endif %}
                            {% endfor %}
                          {% endif %} {{ not found }}
                        timeout: "00:00:01"
                        continue_on_timeout: true
                      - variables:
                          index_pruned_verified: >-
                            {% set vol = state_attr(volume_entity, 'variables') |
                            default({}, true) %} {% set raw =
                            vol.get('_label_index', {}).get('value') if vol is
                            mapping else {} %} {% set found = false %} {% if raw is
                            mapping %}
                              {% for label, drawers in raw.items() %}
                                {% if drawers is mapping %}
                                  {% for sub, arr in drawers.items() %}
                                    {% set al = arr if (arr is iterable and not arr is string) else [arr] %}
                                    {% if single_drawer in al %}{% set found = true %}{% endif %}
                                  {% endfor %}
                                {% elif drawers is iterable and not drawers is string %}
                                  {% if single_drawer in drawers %}{% set found = true %}{% endif %}
                                {% else %}
                                  {% if drawers == single_drawer %}{% set found = true %}{% endif %}
                                {% endif %}
                              {% endfor %}
                            {% endif %} {{ not found }}
              - variables:
                  final_response:
                    status: "{{ 'success' if delete_verified else 'warning' }}"
                    index_maintenance:
                      pruned: "{{ index_changed }}"
                      verified: "{{ index_pruned_verified if index_changed else true }}"
                    message: |-
                      {% if delete_verified %}
                        Deleted drawer '{{ single_drawer }}' (verification confirmed).
                      {% else %}
                        Delete requested for '{{ single_drawer }}' (verification not confirmed — drawer still present or state not yet updated).
                      {% endif %}
              - stop: Delete fired
                response_variable: final_response
          - conditions:
              - condition: template
                value_template: "{{ action_type in ['move', 'copy'] }}"
                alias: Move/Copy Drawer
            sequence:
              - variables:
                  dest_cabinet: "{{ destination_cabinet | default('') }}"
                  dest_drawer: "{{ destination_drawer | default('') | slugify }}"
                  dest_volume: "{{ state_attr(dest_cabinet, 'variables') | default({}, true) }}"
                  src_drawer_data: "{{ initial_volume.get(single_drawer , {}) }}"
                  src_drawer_value: >-
                    {{ src_drawer_data.get('value') if src_drawer_data is mapping
                    else src_drawer_data }}
                  can_write_dest: >-
                    {{ not protect_write or (state_attr(dest_cabinet,
                    'variables').get(dest_drawer) is none) or force_action }}
              - choose:
                  - conditions:
                      - condition: template
                        value_template: "{{ dest_cabinet == '' or dest_drawer == '' }}"
                    sequence:
                      - variables:
                          final_response:
                            status: error
                            message: Missing destination_cabinet or destination_drawer.
                      - stop: Incomplete destination
                        response_variable: final_response
                  - conditions:
                      - condition: template
                        value_template: "{{ not can_write_dest }}"
                    sequence:
                      - variables:
                          final_response:
                            status: error
                            message: >-
                              Target drawer '{{ dest_drawer }}' already exists in
                              '{{ dest_cabinet }}'. Use force_action to overwrite.
                      - stop: Overwrite blocked
                        response_variable: final_response
                  - conditions:
                      - condition: template
                        value_template: "{{ single_drawer == '' or not key_exists_initial }}"
                        alias: Missing Source Drawer
                    sequence:
                      - variables:
                          final_response:
                            status: error
                            message: >-
                              Source drawer '{{ single_drawer }}' does not exist in
                              '{{ volume_entity }}'.
                      - stop: Missing source drawer
                        response_variable: final_response
              - event: set_variable_legacy
                event_data:
                  key: "{{ dest_drawer }}"
                  value: "{{ src_drawer_value }}"
                  set_timestamp: true
                  volume_entity: "{{ dest_cabinet }}"
              - choose:
                  - conditions:
                      - condition: template
                        value_template: "{{ accepted_entity_labels | length > 0 }}"
                        alias: Valid Labels
                    sequence:
                      - alias: Update the Index
                        event: set_variable_legacy
                        event_data:
                          key: _label_index
                          value: "{{ updated_label_index }}"
                          set_timestamp: true
                          volume_entity: "{{ dest_cabinet }}"
                        enabled: false
              - wait_template: >-
                  {% set vol = state_attr(dest_cabinet, 'variables') | default({},
                  true) %} {{ vol.get(dest_drawer, {}).get('value') ==
                  src_drawer_value }}
                timeout: "00:00:01"
                continue_on_timeout: true
              - variables:
                  write_verified: >-
                    {% set vol = state_attr(dest_cabinet, 'variables') | default({},
                    true) %} {{ vol.get(dest_drawer, {}).get('value') ==
                    src_drawer_value }}
              - choose:
                  - conditions:
                      - condition: template
                        value_template: "{{ action_type == 'move' and key_exists_initial }}"
                        alias: Move - Source Delete Required
                    sequence:
                      - event: remove_variable_legacy
                        event_data:
                          key: "{{ single_drawer }}"
                          volume_entity: "{{ volume_entity }}"
                      - wait_template: >-
                          {% set vol = state_attr(volume_entity, 'variables') |
                          default({}, true) %} {{ single_drawer not in vol }}
                        timeout: "00:00:01"
                        continue_on_timeout: true
                      - variables:
                          _raw_index: >-
                            {{ initial_volume.get('_label_index', {}).get('value') |
                            default({}) }}
                          _index_src: >-
                            {{ state_attr(volume_entity, 'variables') | default({},
                            true) }}
                          pruned_index: |-
                            {% if _raw_index is mapping %}
                              {# Build a cleaned copy with `key` removed everywhere #}
                              {% set cleaned = {} %}
                              {% for label, drawers in _raw_index.items() %}
                                {% if drawers is mapping %}
                                  {# Nested form: label -> {sub: [drawers]} #}
                                  {% set kept_sub = {} %}
                                  {% for sub, arr in drawers.items() %}
                                    {% set al = arr if (arr is iterable and not arr is string) else [arr] %}
                                    {% set cleaned_arr = al | reject('equalto', single_drawer) | list %}
                                    {% if cleaned_arr | length > 0 %}
                                      {% set kept_sub = kept_sub | combine({ sub: cleaned_arr }) %}
                                    {% endif %}
                                  {% endfor %}
                                  {% if kept_sub | length > 0 %}
                                    {% set cleaned = cleaned | combine({ label: kept_sub }) %}
                                  {% endif %}
                                {% elif drawers is iterable and not drawers is string %}
                                  {# Flat list form: label -> [drawers] #}
                                  {% set cleaned_list = drawers | reject('equalto', single_drawer) | list %}
                                  {% if cleaned_list | length > 0 %}
                                    {% set cleaned = cleaned | combine({ label: cleaned_list }) %}
                                  {% endif %}
                                {% else %}
                                  {# Single value fallback #}
                                  {% if drawers != single_drawer %}
                                    {% set cleaned = cleaned | combine({ label: [drawers] }) %}
                                  {% endif %}
                                {% endif %}
                              {% endfor %}
                              {{ cleaned }}
                            {% else %}
                              {}
                            {% endif %}
                          index_changed: "{{ _raw_index != pruned_index }}"
                      - choose:
                          - conditions:
                              - condition: template
                                value_template: "{{ index_changed }}"
                                alias: Prune needed
                            sequence:
                              - event: set_variable_legacy
                                event_data:
                                  key: _label_index
                                  value: "{{ pruned_index }}"
                                  set_timestamp: true
                                  volume_entity: "{{ volume_entity }}"
                              - alias: Index prune verification
                                wait_template: >-
                                  {% set vol = state_attr(volume_entity,
                                  'variables') | default({}, true) %} {% set raw =
                                  vol.get('_label_index', {}).get('value') if vol is
                                  mapping else {} %} {% set found = false %} {% if
                                  raw is mapping %}
                                    {% for label, drawers in raw.items() %}
                                      {% if drawers is mapping %}
                                        {% for sub, arr in drawers.items() %}
                                          {% set al = arr if (arr is iterable and not arr is string) else [arr] %}
                                          {% if single_drawer in al %}{% set found = true %}{% endif %}
                                        {% endfor %}
                                      {% elif drawers is iterable and not drawers is string %}
                                        {% if single_drawer in drawers %}{% set found = true %}{% endif %}
                                      {% else %}
                                        {% if drawers == single_drawer %}{% set found = true %}{% endif %}
                                      {% endif %}
                                    {% endfor %}
                                  {% endif %} {{ not found }}
                                timeout: "00:00:01"
                                continue_on_timeout: true
                              - variables:
                                  index_pruned_verified: >-
                                    {% set vol = state_attr(volume_entity,
                                    'variables') | default({}, true) %} {% set raw =
                                    vol.get('_label_index', {}).get('value') if vol
                                    is mapping else {} %} {% set found = false %} {%
                                    if raw is mapping %}
                                      {% for label, drawers in raw.items() %}
                                        {% if drawers is mapping %}
                                          {% for sub, arr in drawers.items() %}
                                            {% set al = arr if (arr is iterable and not arr is string) else [arr] %}
                                            {% if single_drawer in al %}{% set found = true %}{% endif %}
                                          {% endfor %}
                                        {% elif drawers is iterable and not drawers is string %}
                                          {% if single_drawer in drawers %}{% set found = true %}{% endif %}
                                        {% else %}
                                          {% if drawers == single_drawer %}{% set found = true %}{% endif %}
                                        {% endif %}
                                      {% endfor %}
                                    {% endif %} {{ not found }}
              - variables:
                  final_response:
                    status: "{{ 'success' if write_verified else 'warning' }}"
                    message: |-
                      {% if write_verified %}
                        Drawer '{{ single_drawer }}' {{ action_type }}d to '{{ dest_drawer }}' in '{{ dest_cabinet }}'.
                      {% else %}
                        {{ action_type | title }} completed but write verification failed or delayed.
                      {% endif %}
                    verification:
                      confirmed: "{{ write_verified }}"
              - stop: Move/Copy complete
                response_variable: final_response
        default:
          - variables:
              final_response:
                status: error
                message: Uncaught Exception. Use 'help' for usage.
          - stop: Invalid parameters
            response_variable: final_response
    alias: Zen DojoTools FileCabinet (RC1)
    description: >-
      Zen DojoTools FileCabinet (v3.10.1 RC1) 105% More Health, “The One That
      Actually Behaves”
    
      CabinetVolumes are The Library's storage. To use ALWAYS pull a Volume Manifest
      'Manifest' (list of all volumes with rich metadata) FIRST if you do not
      already have it loaded to see what's available. calling the manifest by
      issuing a READ - with None, '', or '*' for 'volume_entity' A directory of a
      single volume (with labels) can be obtained by sending 
        read - valid 'volume_entity' and 'drawer' with None, '', or '*'
      SUPERPOWER! Combine with The Index - Read by label_targets (yes, a list) to
      scan drawers for subjects. STRONG recommendation to HELP() and pull a manifest
      - READ() immediately.
    
      IMPORTANT: Read By Label is currently limited to ONE cabinet at a time.
    fields:
      action_type:
        description: >-
          'manifest', 'create', 'read', 'update', 'delete', 'move', 'copy', 'help'
          (default: help)
        required: true
        selector:
          select:
            options:
              - manifest
              - create
              - read
              - update
              - delete
              - move
              - copy
              - help
        default: manifest
      volume_entity_id:
        description: >-
          Target volume entity_id (NOT guid, must be valid cabinet). Use any of [
          None, '', '*'] to return manifest.  On move / copy only accepts first
          entry as source.
        required: false
        selector:
          entity:
            multiple: true
            filter:
              - domain: sensor
        name: volume_entity
      key:
        description: >-
          Drawer(s) to act on. Drawer names are slugified so 'My Partner' ==
          'my_partner'. Accepts one or multiple drawers.  (Write operations require
          exactly 1 drawer.)
        required: false
        selector:
          text:
            multiple: true
        name: drawer
      value:
        description: Raw value to store under the drawer (required for create/update)
        required: false
        selector:
          text:
            multiline: true
      set_timestamp:
        description: Boolean. Store ISO timestamp alongside value. Defaults to false.
        required: false
        selector:
          boolean: null
        default: false
      label_input:
        description: >-
          Optional. A list of label/tags to associate with this drawer
          (create/update). Comma- or newline-separated.
        required: false
        selector:
          text:
            multiline: false
        name: labels
      label_targets:
        description: >-
          Optional. When reading, filters the returned data by label(s). Accepts a
          single label or a comma/newline-separated list of labels. If left blank,
          label filtering is disabled and normal read behavior applies.
        required: false
        selector:
          text:
            multiline: false
      show_hidden_volumes:
        selector:
          boolean:
        name: Show Hidden Volumes
        description: >-
          Show Hidden / System Volumes (Usually, this is not recommended, only use
          when you're trying to debug, confirm etc.)  System Drawers are always
          hidden.
        required: true
      start:
        description: >-
          Start time in ISO 8601. Userd when searching for entities updated or
          changed after... Defaults to no end date [Experimental - currently unused]
        required: false
        selector:
          text: null
      end:
        description: >-
          End time in ISO 8601. Used when searching for entities updated or changed
          before... Defaults to no end date [Experimental - currently unused]
        required: false
        selector:
          text: null
      filter_domain:
        description: >-
          Filter result list for entities in this domain. [Experimental - currently
          unused]
        selector:
          text: null
      filter_state_operand:
        description: >-
          Filter result list for entities with this operand (must use filter_op) 
          [Experimental - currently unused]
        selector:
          text: null
        name: Filter Operand
      filter_op:
        description: >-
          Filter entity by entity matching state using this operation with filter
          operand to obtain a filtered result [Experimental - currently unused]
        selector:
          select:
            options:
              - equals
              - contains
              - not
              - above
              - below
              - "true"
              - "false"
        name: Filter Operation
      force_action:
        description: >-
          Set flag true to pre-confirm certain advanced actions - see documentation
          for details
        required: false
        selector:
          boolean:
        default: false
      destination_cabinet:
        selector:
          entity:
            filter:
              - domain: sensor
        name: Destination Cabinet
        description: Target Cabinet, REQUIRED for Move / Copy Actions. Must be valid cabinet.
      destination_drawer:
        selector:
          text: null
        name: Destination Drawer
        description: >-
          Target Drawer, REQUIRED for Move / Copy Actions. Drawer name will be
          slugified - 'My Partner' == 'my_partner'
    icon: mdi:folder-key
