script:
  zen_dojotools_todo:
    alias: Zen DojoTools ToDo
    description: >-
      Zen DojoTools ToDo (2.9.5) Unified tool for Home Assistant's `todo.*` domain.
      Use in place of HASS Todo tools, supports limited bulk ops. Supports create,
      read, update, and delete actions for any to-do list entity. Automatically
      detects wildcard (`*`) or blank list names to return all lists with labels and
      friendly names. Allows single-item edits and safe bulk status updates (e.g.,
      mark multiple tasks completed). Returns structured JSON responses suitable for
      automations or AI workflows, and integrates directly with `todo.add_item`,
      `todo.update_item`, and `todo.remove_item` services. Default action_type is
      `read`.
    sequence:
      - variables:
          tool_version: 2.9.5
          action_type: "{{ action_type | default('read') }}"
          items_raw: "{{ items if items is defined else [] }}"
          items: |-
            {% if items_raw is iterable and items_raw is not string %}
              {{ items_raw | select('mapping') | list }}
            {% else %}
              {{ [] }}
            {% endif %}
          invalid_item_shapes: |-
            {{
              items_raw
              | reject('mapping')
              | list
              if action_type in ['update','delete']
              else []
            }}
          missing_uid_items: |-
            {{
              items
              | rejectattr('uid','defined')
              | list
              if action_type in ['update','delete']
              else []
            }}
          raw_items_count: "{{ items_raw | length if items_raw is iterable else 0 }}"
          due_date: "{{ due_date | default('') }}"
          description: "{{ description | default('') }}"
          list_name: "{{ list_name | default('') }}"
          status_raw: "{{ status if status is defined else none }}"
          status: "{{ status_raw | default('needs_action') }}"
          is_list_wildcard: "{{ list_name in ['', None, '*'] }}"
          todo_lists: "{{ states.todo | map(attribute='entity_id') | list }}"
          valid_todo_entities: "{{ states.todo | map(attribute='entity_id') |  map('lower') | list }}"
          todo_list_entity: |-
            {% if list_name[0:5] == 'todo.' %}
              {{ list_name | lower }}
            {% else %}
              todo.{{ list_name | slugify }}
            {% endif %}
          todo_list_entity_exists: "{{ todo_list_entity in valid_todo_entities }}"
          label_targets: >-
            {% set raw = label_targets if label_targets is defined and label_targets
            is not none else [] %} {{
              (
                raw
                if raw is iterable and raw is not string
                else raw.splitlines() if raw is string and '\n' in raw
                else raw.split(',') if raw is string
                else []
              )
              | map('trim') | map('lower') | select('string') | reject('equalto','') | list
            }}
          label_entities: |-
            {{
              label_targets | map('label_entities') | sum(start=[])
              | select('match', '^todo\\.') | unique | list
            }}
          target_lists: |-
            {{
              label_entities
              if label_entities | length > 0
              else (
                todo_lists
                if is_list_wildcard
                else [todo_list_entity]
              )
            }}
          is_items_wildcard: |-
            {{
              raw_items_count == 0
              or (
                raw_items_count == 1
                and items_raw | length == 1
                and items_raw[0] in ['', None, '*']
              )
            }}
          todo_lists_data: |-
            [
            {%- for l in states.todo -%}
              {
                "entity_id": "{{ l.entity_id }}",
                "friendly_name": "{{ l.attributes.friendly_name }}",
                "labels": [
                  {%- for lid in labels(l.entity_id) -%}
                    "{{ label_name(lid) }}"{% if not loop.last %}, {% endif %}
                  {%- endfor -%}
                ]
              }{% if not loop.last %}, {% endif %}
            {%- endfor -%}
            ]
          has_uid_items: |-
            {{
              (
                items | length > 0
                and items | selectattr('uid','defined') | list | length == items | length
              )
              or (
                items | length == 0
                and raw_items_count == 1
                and items_raw[0] is mapping
                and items_raw[0].uid is defined
              )
            }}
          has_mixed_uid_items: |-
            {{
              items | length > 0
              and (
                items | selectattr('uid','defined') | list | length > 0
              )
              and (
                items | selectattr('uid','defined') | list | length < items | length
              )
            }}
      - choose:
          - conditions:
              - condition: template
                value_template: |-
                  {{ action_type == 'help' or action_type not in
                    ['create','read','lists','update','delete'] }}
            sequence:
              - variables:
                  help_data:
                    status: info
                    version: "{{ tool_version | default('') }}"
                    tool: Zen DojoTools ToDo
                    purpose: >-
                      Deterministic CRUD controller for Home Assistant todo.*
                      entities. Enforces strict input shapes. Safe for automation
                      and AI use. No implicit writes or coercion.
                    actions:
                      read:
                        description: Read to-do items grouped by list.
                        requirements:
                          list_name: Optional. Use '*' or blank to read all to-do lists.
                          items: Ignored.
                        hints:
                          - Use read to discover valid item UIDs for update/delete.
                          - Use label_targets to filter which lists are queried.
                        examples:
                          - action_type: read
                            list_name: groceries
                          - action_type: read
                            list_name: "*"
                      lists:
                        description: Enumerate available to-do lists with labels only.
                        requirements: {}
                        hints:
                          - Does not return items.
                          - Useful for discovering list names and labels.
                        examples:
                          - action_type: lists
                      create:
                        description: Create one or more new to-do items in an existing list.
                        requirements:
                          list_name: Required. Must resolve to an existing todo.* entity.
                          items: List of dicts with required `item`.
                        hints:
                          - Strings and wildcards are not accepted.
                          - Each item is created independently.
                        examples:
                          - action_type: create
                            list_name: groceries
                            items:
                              - item: Buy chlorine
                              - item: Test strips
                                due_date: "2025-01-05"
                      update:
                        description: Update existing to-do items by UID.
                        requirements:
                          list_name: Required.
                          items: List of dicts with required `uid`.
                        hints:
                          - Run read first to obtain valid UIDs.
                          - All items must be UID-bound dicts.
                          - No wildcards, strings, or partial objects.
                        examples:
                          - action_type: update
                            list_name: groceries
                            items:
                              - uid: abc123
                                status: completed
                              - uid: def456
                                due_date: "2025-01-10"
                      delete:
                        description: Delete existing to-do items by UID.
                        requirements:
                          list_name: Required.
                          items: List of dicts with required `uid`.
                        hints:
                          - Deletes are explicit and irreversible.
                          - All items must include valid UIDs.
                        examples:
                          - action_type: delete
                            list_name: groceries
                            items:
                              - uid: abc123
                      help:
                        description: Return this help payload.
                    wildcards:
                      list_name:
                        - "'' (blank)"
                        - "*"
                      behavior: Wildcards are allowed only for read and lists actions.
                    guardrails:
                      - Items must be lists of dicts.
                      - Update/delete require UID-bound objects.
                      - No strings, wildcards, or coercion.
                      - Invalid input shapes return errors with coaching.
                    noop_conditions:
                      - No matching action branch
                      - Invalid action_type
                      - Wildcards used with create/update/delete
                      - Target list does not exist
              - stop: Pass response variables back to LLM
                response_variable: help_data
            alias: HELP
          - conditions:
              - condition: template
                value_template: |-
                  {{
                    action_type in ['update','delete']
                    and (
                      invalid_item_shapes | length > 0
                      or missing_uid_items | length > 0
                    )
                  }}
                alias: "Error: UPDATE or DELETE with invalid items"
            sequence:
              - variables:
                  final_response:
                    status: error
                    message: Invalid items payload shape.
                    required_shape:
                      - items must be a list
                      - each item must be a dict
                      - each dict must include 'uid'
                    received:
                      invalid_items: "{{ invalid_item_shapes }}"
                      missing_uid: "{{ missing_uid_items }}"
                    coaching:
                      - Run 'read' first
                      - Pass items exactly as returned
                      - No strings, no wildcards, no partial objects
              - stop: Pass response variables back to LLM
                response_variable: final_response
          - conditions:
              - alias: "Error: UPDATE (mixed UID error)"
                condition: template
                value_template: |
                  {{
                    action_type == 'update'
                    and todo_list_entity_exists
                    and has_mixed_uid_items
                  }}
            sequence:
              - variables:
                  final_response: |-
                    {{
                      {
                        "status": "error",
                        "message": "Mixed UID and non-UID items are not allowed. All items must be UID-bound objects.",
                        "required_field": "uid"
                      }
                    }}
              - stop: Pass response variables back to LLM
                response_variable: final_response
          - conditions:
              - alias: "Error: UPDATE (global status and multiple items)"
                condition: template
                value_template: |
                  {{
                    action_type == 'update'
                    and status_raw is not none
                    and status_raw != ''
                    and items | length > 1
                    and (
                      items
                      | selectattr('status','defined')
                      | list
                      | length == 0
                    )
                  }}
            sequence:
              - variables:
                  final_response: |-
                    {{
                      {
                        "status": "error",
                        "message": "Global status updates require exactly one item unless each item specifies its own status.",
                        "details": {
                          "items_provided": items | length,
                          "global_status": status
                        },
                        "coaching": [
                          "Provide status per item, or",
                          "Update a single item when using global status"
                        ]
                      }
                    }}
              - stop: Global Status Guard
                response_variable: final_response
          - conditions:
              - alias: "Error: DELETE (mixed UID error)"
                condition: template
                value_template: |
                  {{
                    action_type == 'delete'
                    and todo_list_entity_exists
                    and has_mixed_uid_items
                  }}
            sequence:
              - variables:
                  final_response: |-
                    {{
                      {
                        "status": "error",
                        "message": "Mixed UID and non-UID items are not allowed. All items must be UID-bound objects.",
                        "required_field": "uid"
                      }
                    }}
              - stop: Pass response variables back to LLM
                response_variable: final_response
          - conditions:
              - condition: template
                value_template: |
                  {{
                    action_type == 'create'
                    and (
                      items | length == 0
                      or items | selectattr('item','defined') | list | length != items | length
                    )
                  }}
                alias: "Error: CREATE with invalid 'items'"
            sequence:
              - variables:
                  final_response:
                    status: error
                    message: Invalid create items.
                    required_shape:
                      - items must be a list of dicts
                      - each dict must include 'item'
                    coaching:
                      - "Example: { item: Buy milk }"
              - stop: Pass response variables back to LLM
                response_variable: final_response
          - conditions:
              - condition: template
                value_template: "{{ action_type == 'lists' }}"
            sequence:
              - variables:
                  final_response: |-
                    {{
                      {
                        "status": "info",
                        "mode": "lists",
                        "count": todo_lists_data | length,
                        "lists": todo_lists_data
                      }
                    }}
              - stop: Pass response variables back to LLM
                response_variable: final_response
            alias: LIST all lists and labels
          - conditions:
              - condition: template
                value_template: "{{ action_type == 'read' }}"
            sequence:
              - variables:
                  collected: []
              - repeat:
                  for_each: "{{ target_lists }}"
                  sequence:
                    - action: todo.get_items
                      data:
                        entity_id: "{{ repeat.item }}"
                      response_variable: list_items
                    - variables:
                        _items: "{{ list_items.get(repeat.item, {}).get('items', []) }}"
                        filtered_items: |-
                          {% if status in ['needs_action','completed'] %}
                            {{ _items | selectattr('status','equalto', status) | list }}
                          {% else %}
                            {{ _items }}
                          {% endif %}
                        truncated: >-
                          {{ max_items is defined and max_items and (filtered_items
                          | length > max_items) }}
                        return_items: >-
                          {% if max_items is defined and max_items and
                          (filtered_items | length > max_items) %}
                            {{ filtered_items[:max_items] }}
                          {% else %}
                            {{ filtered_items }}
                          {% endif %}
                        collected: |-
                          {{
                            collected + [
                              {
                                "entity_id": repeat.item,
                                "friendly_name": state_attr(repeat.item,'friendly_name'),
                                "labels": labels(repeat.item) | map('label_name') | list,
                                "count": filtered_items | length,
                                "truncated": truncated,
                                "max_items": (max_items if max_items else none),
                                "items": return_items
                              }
                            ]
                          }}
              - variables:
                  final_response: |-
                    {{
                      {
                        "status": "success",
                        "mode": "read",
                        "list_count": collected | length,
                        "filters": {
                          "list_name": list_name,
                          "status": status,
                          "label_targets": label_targets
                        },
                        "lists": collected
                      }
                    }}
              - stop: Pass response variables back to LLM
                response_variable: final_response
            alias: READ Lists (Grouped)
          - conditions:
              - condition: template
                value_template: |-
                  {{
                    action_type == 'create'
                    and todo_list_entity_exists
                    and items | length > 0
                    and items | select('mapping') | list | length == items | length
                    and items | selectattr('item','defined') | list | length == items | length
                  }}
                alias: CREATE Item(s)
            sequence:
              - repeat:
                  for_each: "{{ items }}"
                  sequence:
                    - variables:
                        create_payload: >-
                          {% set itm = repeat.item %} {% set ns = namespace(data={})
                          %}
    
                          {% set ns.data = dict(
                            item=itm.item
                          ) %}
    
                          {% if itm.description is defined %}
                            {% set ns.data = dict(ns.data, description=itm.description) %}
                          {% endif %}
    
                          {% if itm.due_date is defined and itm.due_datetime is not
                          defined %}
                            {% set ns.data = dict(ns.data, due_date=itm.due_date) %}
                          {% endif %}
    
                          {% if itm.due_datetime is defined and itm.due_date is not
                          defined %}
                            {% set ns.data = dict(ns.data, due_datetime=itm.due_datetime) %}
                          {% endif %}
    
                          {{ ns.data }}
                    - action: todo.add_item
                      target:
                        entity_id: "{{ todo_list_entity }}"
                      data: "{{ create_payload }}"
              - variables:
                  final_response:
                    status: success
                    message: >-
                      Created {{ items | length }} item(s) in list '{{ list_name
                      }}'.
                    list_name: "{{ list_name }}"
                    items: "{{ items }}"
              - stop: Pass response variables back to LLM
                response_variable: final_response
          - conditions:
              - alias: UPDATE (by UID)
                condition: template
                value_template: |
                  {{
                    action_type == 'update'
                    and todo_list_entity_exists
                    and not is_list_wildcard
                    and has_uid_items
                  }}
            sequence:
              - choose:
                  - conditions:
                      - condition: template
                        value_template: |-
                          {{
                            items | length > 0
                            and items | selectattr('uid','defined') | list | length == items | length
                          }}
                        alias: UID-only update
                    sequence:
                      - repeat:
                          for_each: "{{ items }}"
                          sequence:
                            - variables:
                                update_payload: >-
                                  {% set itm = repeat.item %}
    
                                  {% set ns = namespace(data={}) %}
    
    
                                  {# REQUIRED: UID goes in `item`, not `uid` #}
    
                                  {% set ns.data = dict(
                                    entity_id=todo_list_entity,
                                    item=itm.uid
                                  ) %}
    
    
                                  {# OPTIONAL FIELDS #}
    
                                  {% if itm.rename is defined %}
                                    {% set ns.data = dict(ns.data, rename=itm.rename) %}
                                  {% endif %}
    
    
                                  {% if itm.status is defined %}
                                    {% set ns.data = dict(ns.data, status=itm.status) %}
                                  {% endif %}
    
    
                                  {% if itm.due_date is defined and itm.due_datetime
                                  is not defined %}
                                    {% set ns.data = dict(ns.data, due_date=itm.due_date) %}
                                  {% endif %}
    
    
                                  {% if itm.due_datetime is defined and itm.due_date
                                  is not defined %}
                                    {% set ns.data = dict(ns.data, due_datetime=itm.due_datetime) %}
                                  {% endif %}
    
    
                                  {% if itm.description is defined %}
                                    {% set ns.data = dict(ns.data, description=itm.description) %}
                                  {% endif %}
    
    
                                  {{ ns.data }}
                            - action: todo.update_item
                              data: "{{ update_payload }}"
                      - variables:
                          final_response: |-
                            {{
                              {
                                "status": "success",
                                "message": "Updated " ~ (items | length) ~ " item(s) in list '" ~ list_name ~ "'.",
                                "list_name": list_name,
                                "items": items
                              }
                            }}
                      - stop: Pass response variables back to LLM
                        response_variable: final_response
                default:
                  - variables:
                      final_response: |-
                        {{
                          {
                            "status": "error",
                            "message": "Update operations require item UID(s). Run 'read' first to obtain UIDs.",
                            "required_field": "uid"
                          }
                        }}
                  - stop: Pass response variables back to LLM
                    response_variable: final_response
          - conditions:
              - alias: DELETE (by UID)
                condition: template
                value_template: |
                  {{
                    action_type == 'delete'
                    and todo_list_entity_exists
                    and not is_list_wildcard
                    and has_uid_items
                  }}
            sequence:
              - repeat:
                  for_each: "{{ items }}"
                  sequence:
                    - action: todo.remove_item
                      data:
                        item: "{{ repeat.item.uid }}"
                      target:
                        entity_id: "{{ todo_list_entity }}"
              - variables:
                  final_response: |-
                    {{
                      {
                        "status": "success",
                        "message": "Deleted " ~ (items | length) ~ " item(s) from list '" ~ list_name ~ "'.",
                        "list_name": list_name,
                        "deleted": items
                      }
                    }}
              - stop: Pass response variables back to LLM
                response_variable: final_response
      - variables:
          final_response: |-
            {{
              final_response
              | default(
                {
                  "status": "noop",
                  "message": "No matching branch produced a response."
                }
              )
            }}
      - stop: Pass context
        response_variable: final_response
    fields:
      action_type:
        description: "'lists', 'create', 'read', 'update', 'delete', 'help' (Default: read)"
        selector:
          select:
            options:
              - lists
              - create
              - read
              - update
              - delete
              - help
        default: read
      list_name:
        description: To-do list name (default '' or '*' = all lists)
        selector:
          text: null
      items:
        description: >-
          For create: task summaries or objects. For update/delete: list of dicts
          with required 'uid' identified by UID only.
        selector:
          text:
            multiple: true
      status:
        selector:
          select:
            options:
              - needs_action
              - completed
        default: needs_action
        description: Return items matching the selected status
      label_targets:
        selector:
          text:
            multiple: true
        description: >-
          Optional: 'read by label' One or more Home Assistant label names used to
          select which to-do lists and items are returned.
      rename:
        selector:
          text: null
        name: new_name
        description: Optional, use with Update - The new name/summary of the to-do item.
      max_items:
        selector:
          number:
            min: 1
            max: 500
        name: Max Items
        description: "Optional: Limit the maximum number of items returned per list."
      due_date:
        selector:
          text: null
        name: Due Date
        description: >-
          Expected completion date for the to-do item. Must be provided in ISO-8601
          date format (YYYY-MM-DD).
      due_datetime:
        selector:
          text: null
        name: Due DateTime
        description: >-
          Expected completion date and time for the to-do item. Must be provided in
          ISO-8601 datetime format (YYYY-MM-DDTHH:MM:SSÂ±HH:MM or Z).
      description:
        selector:
          text: null
        name: Description
        description: >-
          Optional: A more complete description than the one provided by the item
          summary. Put details here.
    icon: mdi:clipboard-check-multiple
