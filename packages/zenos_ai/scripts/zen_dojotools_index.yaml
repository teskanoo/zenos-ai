script:
  zen_dojotools_index:
    sequence:
    - variables:
        tool_version: 4.0.3
    - alias: Show Help
      choose:
      - conditions:
        - condition: template
          value_template: "{{ mode == 'help' }}"
        sequence:
        - action: script.zen_dojotools_query
          metadata: {}
          data:
            mode: help
            filter_json: "{} "
          response_variable: zen_query_help
        - variables:
            query_help: |-
              {% if zen_query_help is mapping %}
                {{ zen_query_help }}
              {% else %}
                {{ zen_query_help | from_json }}
              {% endif %}
            help_json: |-
              {{
                {
                  "tool": "Zen DojoTools Index",
                  "version": tool_version | default(None),
                  "intent": "High-resolution reasoning. Convert arbitrary entity + label sets into a unified hypergraph suitable for fusion, summarization, planning, and contextual inference.",
                  "you_should_use_this_tool_when": [
                    "You need to combine labels, entities, or both into a logical result set.",
                    "You need a graph view (nodes/edges/adjacency) rather than a flat list.",
                    "You are preparing input for a summarizer, fusion model, or kata update.",
                    "You need deterministic state discovery that respects Home Assistant labels, drawers, areas, and metadata.",
                    "You want to intersect, union, invert, or xor two sets safely.",
                    "You need an optional ZenQuery filter_json pass."
                  ],
                  "core_behavior": {
                    "pipeline_order": "Collect & Join → ZQ1 Filter → Hypergraph Generation → Optional Expand via Inspect",
                    "join_logic": "Computes op1 (entities_1+label_1) and op2 (entities_2+label_2), evaluates with operator.",
                    "zq1_filtering": "If filter_json is provided, results are passed through ZenQuery before expansion.",
                    "graph_mode": "If mode='hypergraph', output includes nodes, edges, adjacency, and graph index.",
                    "expansion": "If expand_entities=true, metadata/drawers/attributes are emitted."
                  },
                  "modes": {
                    "normal": "Output is lists only, intended for lightweight Dojo operations.",
                    "hypergraph": "Output is graph-based (nodes, edges, adjacency). Use this before summarizers."
                  },
                  "inputs": {
                    "entities_1": "List of entity_ids for Set A.",
                    "label_1": "Label or token resolved into Set A when entities_1 is empty.",
                    "entities_2": "List of entity_ids for Set B.",
                    "label_2": "Label or token resolved into Set B when entities_2 is empty.",
                    "operator": "AND | OR | NOT | XOR",
                    "expand_entities": "true/false — emit detailed inspection blocks.",
                    "filter_json": "ZenQuery-style dict for filtering.",
                    "mode": "normal | hypergraph",
                    "timeout": "Callback timeout in seconds"
                  },
                  "filter_json": {
                    "overview": "ZenQuery dict applied after initial set logic.",
                    "query_help": query_help,
                    "simple_examples": {
                      "domain": {"domain": "light"},
                      "state": {"state": "on"},
                      "label": {"label": "kitchen"}
                    },
                    "compound_examples": {
                      "domain_and_label": {"domain": "sensor", "label": "environment"},
                      "state_exclusion": {"state_not": ["unknown","unavailable"]},
                      "threshold": {"state_op": ">", "state_value": 50}
                    },
                    "advanced_examples": {
                      "multi_filter": {"domain": "switch", "label": "office", "state": "on"},
                      "edge_focus": {"edge_label": "hvac"}
                    }
                  },
                  "hypergraph_output": {
                    "nodes": "Final surviving entity_ids.",
                    "edges": "Labels associated across all surviving entities.",
                    "adjacency": "Cross-product map of entities ↔ labels.",
                    "expanded": "Optional deep entity attributes."
                  },
                  "full_output_structure": {
                    "result.simple": "Flat list of resolved entities.",
                    "result.expanded": "Entity metadata if expand_entities=true.",
                    "result.index": "Entity→label map.",
                    "result.drawers": "All drawers matched.",
                    "result.drawer_adjacent_labels": "Labels found in drawers.",
                    "result.hypergraph": "Graph object when mode='hypergraph'.",
                    "operator": "Operator used.",
                    "inputs": "Echo of user inputs for audit.",
                    "error": "Timeout or semantic error info."
                  },
                  "usage_examples": {
                    "basic": "location AND kitchen",
                    "set": {
                      "entities_1": ["light.kitchen_ceiling"],
                      "label_2": "critical",
                      "operator": "OR"
                    },
                    "nested": {
                      "index_1": { "label_1": "kitchen" },
                      "index_2": { "label_1": "temperature" },
                      "operator": "AND"
                    },
                    "hyper": {
                      "label_1": "friday",
                      "operator": "AND",
                      "mode": "hypergraph",
                      "expand_entities": true
                    }
                  },
                  "best_practices": [
                    "HyperIndex before any fusion or summarizer task.",
                    "Prefer labels over direct entity lists.",
                    "Use filters to avoid bloat.",
                    "Hypergraph mode for reasoning; normal mode for fast lookups.",
                    "Always pre-Index before writing Kata."
                  ],
                  "warnings": [
                    "Expanded blocks can get large.",
                    "Malformed filter_json defaults to empty filter.",
                    "Reasoners should prune aggressively."
                  ],
                  "ai_user_guidance": [
                    "Set mode='help' to retrieve this schema.",
                    "Hypergraph mode reveals relationships; normal mode retrieves sets.",
                    "Use filter_json to shape datasets before reasoning.",
                    "Always get a fresh HyperIndex snapshot before fusion or Kata work.",
                    "Use recursion only with thoughtful intent — max depth is fixed internally."
                  ]
                }
              }}
        - stop: Return help JSON
          response_variable: help_json
    - variables:
        operator: "{{ operator | default('AND') }}"
        _raw_filter: "{{ filter_json | default('{}') }}"
        parsed_filter: |-
          {%- set txt = (_raw_filter | string | trim) -%}
          {%- if _raw_filter is mapping -%}
            {{ _raw_filter }}
          {%- elif txt == '' -%}
            {}
          {%- else -%}
            {%- set parsed = txt | from_json -%}
            {{ parsed if parsed is mapping else {} }}
          {%- endif -%}
        has_filter: |-
          {% if parsed_filter is mapping and parsed_filter | length > 0 %}
            true
          {% else %}
            false
          {% endif %}
    - variables:
        mode: "{{ mode | default('normal') }}"
        is_index_command: "{{ index_command is defined and index_command | length > 0 }}"
        index_command: "{{ index_command | default('') }}"
        index_command_original: "{{ index_command if is_index_command else none }}"
        correlation_id: |-
          {% if is_index_command %}
            {{ now().isoformat() ~ '-' ~ (range(1000) | random) }}
          {% else %} '' {% endif %}
        timeout_seconds: "{{ timeout | default(2) }}"
    - choose:
      - conditions:
        - condition: template
          value_template: "{{ is_index_command }}"
        sequence:
        - event: zen_indexer_request
          event_data:
            index_command: "{{ index_command }}"
            correlation_id: "{{ correlation_id }}"
        - wait_for_trigger:
          - trigger: event
            event_type: zen_index_response
            event_data:
              correlation_id: "{{ correlation_id }}"
          timeout:
            seconds: "{{ timeout_seconds }}"
        - choose:
          - conditions:
            - condition: template
              value_template: "{{ wait.trigger is defined and wait.trigger is not none }}"
            sequence:
            - variables:
                simple: >-
                  {{ wait.trigger.event.data.response.result.simple |
                  default([]) }}
                index_timeout: false
          - conditions: []
            sequence:
            - variables:
                simple: []
                index_timeout: true
                timeout_error_msg: Indexer call timeout {{ timeout_seconds }}s
    - variables:
        index_command: ""
        op1: >-
          {% set ents = simple if (simple is defined and simple) else [] %} {% if
          ents | length == 0 %}
            {% set ents = entities_1 | default([]) %}
            {% if ents | length == 0 and label_1 %}
              {{ label_entities(label_1) }}
            {% else %}
              {{ ents }}
            {% endif %}
          {% else %}
            {{ ents }}
          {% endif %}
        op2: >-
          {% set ents = entities_2 | default([]) %} {% set has_label_2 = (label_2
          is defined and label_2 | default('') | trim != '') %} {% if ents |
          length == 0 and has_label_2 %}
            {{ label_entities(label_2) }}
          {% else %}
            {{ ents }}
          {% endif %}
        op1_empty: "{{ op1 | length == 0 }}"
        op2_empty: "{{ op2 | length == 0 }}"
        setop: "{{ operator | default('AND') | upper }}"
    - variables:
        entities_base: |-
          {% if not op1_empty and op2_empty %}
            {{ op1 }}
          {% elif not op2_empty and op1_empty %}
            {{ op2 }}
          {% elif not op1_empty and not op2_empty %}
            {% if setop == 'AND' %}
              {{ op1 | intersect(op2) }}
            {% elif setop == 'OR' %}
              {{ (op1 + op2) | unique | list }}
            {% elif setop == 'NOT' %}
              {{ op1 | difference(op2) }}
            {% elif setop == 'XOR' %}
              {{ op1 | symmetric_difference(op2) }}
            {% else %}
              {{ (op1 + op2) | unique | list }}
            {% endif %}
          {% else %}
            []
          {% endif %}
    - alias: "Zen Query: Filter entities_base if filter passed"
      if:
      - condition: template
        value_template: "{{ has_filter }}"
        alias: "Has Filter: filter_json exists and is mapping"
      then:
      - action: script.zen_dojotools_query
        metadata: {}
        data:
          mode: query
          filter_json: |
            {{ parsed_filter | tojson }}
          target_entities: "{{ entities_base }}"
        response_variable: response_zen_query
      - variables:
          response_entities: "{{ response_zen_query.baselist | default([]) }}"
          fallback_entities_base: "{{ entities_base | default([]) }}"
          strict_mode: "{{ strict | default(false) }}"
          entities_base: |-
            {% if strict_mode %}
              {{ response_entities }}
            {% else %}
              {{ response_entities if response_entities else fallback_entities_base }}
            {% endif %}
    - alias: "Prepare [ Expand ] Result Set "
      choose:
      - conditions:
        - condition: template
          value_template: "{{ expand_entities }}"
          alias: Expand = true
        sequence:
        - action: script.zen_dojotools_inspect
          data:
            entity_id: "{{ entities_base | list }}"
          response_variable: response
        - variables:
            expanded_entities: "{{ response.results | default([]) }}"
            matched_drawers: "{{ response.drawers | default([]) }}"
            matched_drawer_labels: "{{ response.adjacent_labels | default([]) }}"
      - conditions: []
        sequence:
        - variables:
            expanded_entities: "{{ entities_base }}"
            matched_drawers: []
            matched_drawer_labels: []
        alias: Expand = false
    - variables:
        adjacent_labels: |-
          {%- set ns = namespace(labels=[]) -%} {%- for e in entities_base -%}
            {%- set ns.labels = ns.labels + (labels(e) | list) -%}
          {%- endfor -%} {{ ns.labels | unique | list | sort }}
        result_index: |-
          {% if op1_empty and op2_empty %}
            {{ labels() | list | sort }}
          {% else %}
            {% set ns = namespace(idx=[]) %}
            {% for e in entities_base %}
              {% set ns.idx = ns.idx + [[ e, (labels(e) | list) ]] %}
            {% endfor %}
            {{ ns.idx }}
          {% endif %}
    - variables:
        hypergraph: |-
          {% if mode == 'hypergraph' %}
            {
              "nodes": {{ entities_base | tojson }},
              "edges": {{ adjacent_labels | tojson }},
              "expanded": {{ expanded_entities | tojson }}
            }
          {% else %}
            {}
          {% endif %}
    - variables:
        label_entity_logic_result_raw: |-
          {{
            {
              "result": {
                "simple": entities_base | default([]) | list,
                "expanded": expanded_entities | default({}),
                "adjacent_labels": adjacent_labels | default([]) | list,
                "index": result_index | default([]),
                "drawers": matched_drawers | default([]) | list,
                "drawer_adjacent_labels": matched_drawer_labels | default([]) | list,
                "hypergraph": hypergraph | default({})
              },
              "inputs": {
                "mode": mode | default('normal'),
                "index_command": index_command_original | default({}),
                "entities_1": entities_1 | default([]) | list,
                "label_1": label_1 | default(''),
                "entities_2": entities_2 | default([]) | list,
                "label_2": label_2 | default(''),
                "filter_json": parsed_filter | default({}),
                "strict": strict | default(false),
                "expand_entities": expand_entities | default(false)
          
              },
              "operator": "*" if (op1_empty and op2_empty) else setop,
              "error": timeout_error_msg | default(None)
            }
            | tojson
          }}
        label_entity_logic_result: "{{ label_entity_logic_result_raw | from_json | default({}) }}"
    - stop: Zen DojoTools Index Complete
      response_variable: label_entity_logic_result
alias: Zen DojoTools Index (RC1)
description: >
  Zen DojoTools HyperIndex (4.0.3 RC1)
    Universal HyperGraph index for entity, label, drawer, and metadata reasoning.
  Combines labels, entities, drawers, and contextual metadata into one
  deterministic result set. Takes two input sets (labels or entities), applies
  logical operators (AND, OR, NOT, XOR, *), and resolves them through the Zen
  Label Graph. Filtering via filter_json (ZQ-1) trims candidates before
  expansion. When expand_entities=true, the tool calls Zen Inspect to gather
  attributes, drawers, related labels, and node data. Hypergraph mode outputs a
  structured graph (nodes, edges, adjacency, expanded) for fusion layers,
  summarizers, drift checks, and reasoning tasks. Results return as a stable
  JSON object with simple lists, expanded details, adjacency, mappings, drawer
  lookups, and any errors. Run with mode: help for full syntax and ZQ-1 schema.
fields:
  mode:
    selector:
      select:
        options:
        - normal
        - hypergraph
        - help
    default: normal
    description: >-
      Index mode. Required, normal (default) - lightweight traditional index,
      hypergraph adds nodes, edges and adjacency, help - usage details incl zq1
      syntax.
  index_command:
    name: Zen Index Command
    description: >-
      Overrides all fields. JSON or simple query. Supports nested
      index_1/index_2 (depth ≤3). Use filter_json for filters.
    required: false
    selector:
      text: {}
  entities_1:
    name: Entities 1
    description: one of Entities 1 or Label 1 must be passed.
    required: false
    selector:
      entity:
        multiple: true
  label_1:
    description: one of Label 1 or Entities 1 must be passed.
    name: Label 1
    required: false
    selector:
      text: {}
  entities_2:
    name: Entities 2
    required: false
    selector:
      entity:
        multiple: true
  label_2:
    name: Label 2
    required: false
    selector:
      text: {}
  operator:
    name: Set Operator
    description: Boolean set operator - Default AND if not provided.
    required: false
    default: AND
    selector:
      select:
        options:
        - AND
        - OR
        - NOT
        - XOR
  timeout:
    name: Timeout
    required: false
    default: 2
    selector:
      number:
        min: 0
        max: 5
        step: 0.25
  filter_json:
    selector:
      text:
        multiline: true
    default: "{} "
    description: >-
      Optional filter_json json dict containing a valid ZenQuery filter
      dictionary - MUST see zen_query help for ZQ1 schema and use. Default {}
  strict:
    selector:
      boolean: {}
    description: >
      If true, ZQ1’s output is taken as authoritative even when empty. No
      fallback to the original entity set. Use this for reasoning tasks where an
      empty set is semantically meaningful.
    required: false
    default: false
  expand_entities:
    name: Expand Results
    required: false
    default: false
    selector:
      boolean: {}
mode: parallel
max: 10
icon: mdi:graphql
