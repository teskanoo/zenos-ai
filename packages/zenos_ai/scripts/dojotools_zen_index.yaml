script:
  dojotools_zen_index:
    alias: DojoTOOLS Zen Index
    description: >-
      The Zen Index (2.6.0) The next version of the Library ~INDEX~ Command.  ALWAYS
      prefer it over old index tools. Can perform set logic on two lists of
      entity_ids (each resolved from a label or list of entities). - If only one
      side provided, returns that set. - If both, applies operator (AND, OR, NOT,
      XOR). - If neither, returns an error or (special case) full label index
      (operator = '*'). - Optional expand to resolve groups/areas. Uses Zen Inspect
      to return matching entities, cabinets and drawers, adjacent labels, expansion
      can include state and attribute list. result.simple ALWAYS returns a list (for
      chaining). If index_command is set, fires zen_indexer_request event and exits
      for recursive resolution. Note this fille will be renamed next release.
    fields:
      index_command:
        name: Zen Index Command
        description: >-
          Structured query string (if set, all other fields are ignored and this
          triggers recursive index resolution via event). If parsing fails or times
          out, will fall back to using the other fields.
        required: false
        selector:
          text:
      entities_1:
        name: Entities 1
        description: List of entity_ids for operand 1 (used if label_1 is blank)
        required: false
        selector:
          entity:
            multiple: true
      label_1:
        name: Label 1
        description: Label for operand 1 (used if entities_1 is empty)
        required: false
        selector:
          text:
      entities_2:
        name: Entities 2
        description: List of entity_ids for operand 2 (used if label_2 is blank)
        required: false
        selector:
          entity:
            multiple: true
      label_2:
        name: Label 2
        description: Label for operand 2 (used if entities_2 is empty)
        required: false
        selector:
          text:
      operator:
        name: Set Operator
        description: Logical set operator to apply between operand 1 and 2 (AND, OR, NOT, XOR)
        required: true
        default: AND
        selector:
          select:
            options:
              - AND
              - OR
              - NOT
              - XOR
      expand_entities:
        name: Expand results
        description: >-
          If true, expand each resulting entity to include its state and attribute
          keys (may produce a large output). Best practice: use labels to narrow
          results before expanding. Default: false.
        required: false
        default: false
        selector:
          boolean:
      timeout:
        name: Timeout
        description: >-
          Timeout (in seconds) to wait for index resolution via event if using
          index_command.  Default 2 seconds (max 5). If timeout occurs, script will
          fall back to using provided fields or full index.
        required: false
        default: 2
        selector:
          number:
            min: 0
            max: 5
            step: 0.25
    sequence:
      - variables:
          is_index_command: "{{ index_command is defined and index_command | length > 0 }}"
          correlation_id: |-
            {% if index_command is defined and index_command | length > 0 %}
              {{ now().isoformat() ~ '-' ~ (range(1000) | random) }}
            {% else %}
              ''
            {% endif %}
          timeout_seconds: "{{ timeout | default(2) }}"
      - choose:
          - conditions:
              - condition: template
                value_template: "{{ is_index_command }}"
            sequence:
              - alias: Send Index Command to Parser
                event: zen_indexer_request
                event_data:
                  index_command: "{{ index_command }}"
                  correlation_id: "{{ correlation_id }}"
              - alias: Wait for Parser Response ({{ timeout_seconds }}s)
                wait_for_trigger:
                  - event_type: zen_index_response
                    event_data:
                      correlation_id: "{{ id }}"
                    trigger: event
                timeout:
                  seconds: "{{ timeout_seconds }}"
              - choose:
                  - conditions:
                      - condition: template
                        value_template: "{{ wait.trigger is defined and wait.trigger is not none }}"
                    sequence:
                      - variables:
                          simple: "{{ wait.trigger.event.data.response.result.simple }}"
                          index_timeout: false
                  - conditions: []
                    sequence:
                      - variables:
                          simple: []
                          index_timeout: true
                          timeout_error_msg: Indexer call timeout {{ timeout_seconds }}s
            alias: Send Index Command to Parser and resolve to fields
      - variables:
          index_command: ""
          op1: >-
            {% set ents = simple if (simple is defined and simple) else [] %} {% if
            ents | length == 0 %}
              {% set ents = entities_1 if (entities_1 is defined and entities_1) else [] %}
              {% if ents | length == 0 and label_1 %}
                {{ label_entities(label_1) }}    # If still empty and label_1 provided, retrieve entities by label_1
              {% else %}
                {{ ents }}
              {% endif %}
            {% else %}
              {{ ents }}
            {% endif %}
          op2: >-
            {% set ents = entities_2 if (entities_2 is defined and entities_2) else
            [] %} {% if ents | length == 0 and label_2 %}
              {{ label_entities(label_2) }}
            {% else %}
              {{ ents }}
            {% endif %}
          op1_empty: "{{ op1 | length == 0 }}"
          op2_empty: "{{ op2 | length == 0 }}"
          setop: "{{ operator | default('AND') | upper }}"
          entities_base: |-
            {% if not op1_empty and op2_empty %}
              {{ op1 }}
            {% elif not op2_empty and op1_empty %}
              {{ op2 }}
            {% elif not op1_empty and not op2_empty %}
              {% if setop == 'AND' %}
                {{ op1 | intersect(op2) }}
              {% elif setop == 'OR' %}
                {{ op1 + op2 | unique | list }}
              {% elif setop == 'NOT' %}
                {{ op1 | difference(op2) }}
              {% elif setop == 'XOR' %}
                {{ op1 | symmetric_difference(op2) }}
              {% else %}
                {{ op1 + op2 | unique | list }}
              {% endif %}
            {% else %}
              []   # Both op1 and op2 empty: no entities in base set (will trigger full index fallback below)
            {% endif %}
      - if:
          - condition: template
            value_template: "{{ expand_entities }}"
            alias: if expand_entities
        then:
          - action: script.dojotools_zen_inspect
            metadata: {}
            data:
              entity_id: "{{entities_base}}"
            response_variable: response
          - stop: Pass Variable
            response_variable: response
            enabled: false
          - variables:
              expanded_entities: "{{ response }}"
        else:
          - variables:
              expanded_entities: []
      - variables:
          result_simple: "{{ entities_base | tojson }}"
          adjacent_labels: |-
            {%- set ns = namespace(all_labels=[], index_list=[]) -%} {%- for e in entities_base -%}
              {%- set ns.all_labels = ns.all_labels + (labels(e) | list) -%}
            {%- endfor -%} {{ ns.all_labels | unique | list | tojson }}
          result_index: |-
            {%- set ns = ns if ns is defined else namespace(all_labels=[], index_list=[]) -%} {%- for e in entities_base -%}
              {%- set ns.index_list = ns.index_list + [[ e, (labels(e) | list) ]] -%}
            {%- endfor -%} {{ ns.index_list | tojson }}
          error_msg: |-
            {% set msg = '' %} {% if index_timeout is defined and index_timeout %}
              {% set msg = 'Indexer call timeout ' ~ timeout_seconds ~ 's. Fallback path used.' %}
            {% elif op1_empty and op2_empty %}
              {% set msg = 'Both operands are empty. Returned full label index.' %}
            {% endif %} {{ msg }}  # msg will be empty string if no error
          label_entity_logic_result_raw: |-
            { 
              "result": {
                "simple": {{ result_simple }},
                "expanded": {{ expanded_entities }},
                "adjacent_labels": {{ adjacent_labels }},
                "index": {% if op1_empty and op2_empty %} {{ labels() | list | tojson }} {% else %} {{ result_index }} {% endif %}
              },
              "operator": "{{ "*" if (op1_empty and op2_empty) else setop }}",
              "inputs": {
                "entities_1": {{ (entities_1 | default([])) | tojson }},
                "label_1": {{ (label_1 | default('')) | tojson }},
                "entities_2": {{ (entities_2 | default([])) | tojson }},
                "label_2": {{ (label_2 | default('')) | tojson }},
                "expand_entities": {{ (expand_entities | default(false)) | tojson }}
              },
              "error": {{ (error_msg if error_msg != '' else none) | tojson }}
            }
          label_entity_logic_result: "{{ label_entity_logic_result_raw | from_json | default({}) }}"
      - stop: Zen Index Call Complete
        response_variable: label_entity_logic_result
    mode: parallel
    max: 10
